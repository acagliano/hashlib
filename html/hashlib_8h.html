<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hashlib CE: hashlib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hashlib CE
   &#160;<span id="projectnumber">6</span>
   </div>
   <div id="projectbrief">A cryptography library for the TI-84+ CE</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hashlib.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Cryptography Library for the TI-84+ CE.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="hashlib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__sha256__ctx.html">_sha256_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__aes__ctx.html">_aes_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a97c7527aa5efe0f229c45c54ebcc6b55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a97c7527aa5efe0f229c45c54ebcc6b55">hashlib_FastMemBufferSafe</a>&#160;&#160;&#160;((void*)0xE30A04)</td></tr>
<tr class="separator:a97c7527aa5efe0f229c45c54ebcc6b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab981c88a4cd7407b2c4b4bfe86fc021b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ab981c88a4cd7407b2c4b4bfe86fc021b">hashlib_FastMemBufferUnsafe</a>&#160;&#160;&#160;((void*)0xE30800)</td></tr>
<tr class="separator:ab981c88a4cd7407b2c4b4bfe86fc021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939c5eb79064fb776e34fd0c632a588b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a939c5eb79064fb776e34fd0c632a588b">SHA256_MBUFFER_LEN</a>&#160;&#160;&#160;(64 * 4)</td></tr>
<tr class="separator:a939c5eb79064fb776e34fd0c632a588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aa539ae202ddf9e0c9211309869fc8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#af5aa539ae202ddf9e0c9211309869fc8">SHA256_DIGEST_LEN</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:af5aa539ae202ddf9e0c9211309869fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a767ce32adaa3ad3e7e4aafff0ae7e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a7a767ce32adaa3ad3e7e4aafff0ae7e3">SHA256_HEXSTR_LEN</a>&#160;&#160;&#160;(<a class="el" href="hashlib_8h.html#af5aa539ae202ddf9e0c9211309869fc8">SHA256_DIGEST_LEN</a>&lt;&lt;1) + 1</td></tr>
<tr class="separator:a7a767ce32adaa3ad3e7e4aafff0ae7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab0742642db9c0609c00bf8a54f386f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:afab0742642db9c0609c00bf8a54f386f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc06a029c783f78badc2c26cf6f2297c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#afc06a029c783f78badc2c26cf6f2297c">AES_IV_SIZE</a>&#160;&#160;&#160;<a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a></td></tr>
<tr class="separator:afc06a029c783f78badc2c26cf6f2297c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf32bb8a8d871f4cf33f26c8b2a977fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#acf32bb8a8d871f4cf33f26c8b2a977fb">AES_MAC_SIZE</a>&#160;&#160;&#160;<a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a></td></tr>
<tr class="separator:acf32bb8a8d871f4cf33f26c8b2a977fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2841462d8933d0982e3ea13dc5284d7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a2841462d8933d0982e3ea13dc5284d7c">AES128_KEYLEN</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a2841462d8933d0982e3ea13dc5284d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ba5c621bf4af2ddcb851e179e21623"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a37ba5c621bf4af2ddcb851e179e21623">AES192_KEYLEN</a>&#160;&#160;&#160;24</td></tr>
<tr class="separator:a37ba5c621bf4af2ddcb851e179e21623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bab8a778d065da4cc561f4813994f03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a7bab8a778d065da4cc561f4813994f03">AES256_KEYLEN</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a7bab8a778d065da4cc561f4813994f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f9757a799b724cfd578ac0a45f58be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#af7f9757a799b724cfd578ac0a45f58be">hashlib_AESPaddedSize</a>(len)&#160;&#160;&#160;	((((len)%<a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a>)==0) ? (len) + <a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a> : (((len)&gt;&gt;4) + 1)&lt;&lt;4)</td></tr>
<tr class="separator:af7f9757a799b724cfd578ac0a45f58be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140213b514394151a1d6ba410ec32bc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a140213b514394151a1d6ba410ec32bc4">hashlib_AESCiphertextLen</a>(len)&#160;&#160;&#160;(<a class="el" href="hashlib_8h.html#af7f9757a799b724cfd578ac0a45f58be">hashlib_AESPaddedSize</a>((len)) + <a class="el" href="hashlib_8h.html#afc06a029c783f78badc2c26cf6f2297c">AES_IV_SIZE</a>)</td></tr>
<tr class="separator:a140213b514394151a1d6ba410ec32bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e00bf4bceabd69cff65a5cbf685bd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a89e00bf4bceabd69cff65a5cbf685bd1">hashlib_AESAuthMacCiphertextLen</a>(len)&#160;&#160;&#160;	(<a class="el" href="hashlib_8h.html#a140213b514394151a1d6ba410ec32bc4">hashlib_AESCiphertextLen</a>((len)) + <a class="el" href="hashlib_8h.html#acf32bb8a8d871f4cf33f26c8b2a977fb">AES_MAC_SIZE</a>)</td></tr>
<tr class="separator:a89e00bf4bceabd69cff65a5cbf685bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4277e4f58f162b211ca4c2a38c2a5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#abc4277e4f58f162b211ca4c2a38c2a5a">hashlib_AESAuthSha256CiphertextLen</a>(len)&#160;&#160;&#160;	(<a class="el" href="hashlib_8h.html#a140213b514394151a1d6ba410ec32bc4">hashlib_AESCiphertextLen</a>((len)) + <a class="el" href="hashlib_8h.html#af5aa539ae202ddf9e0c9211309869fc8">SHA256_DIGEST_LEN</a>)</td></tr>
<tr class="separator:abc4277e4f58f162b211ca4c2a38c2a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864d96afe89419821aed4293d979b2b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a864d96afe89419821aed4293d979b2b9">hashlib_AESKeygen</a>(key,  keylen)&#160;&#160;&#160;<a class="el" href="hashlib_8h.html#aa0092aa4c122591fae447dda8fa25dfc">hashlib_RandomBytes</a>((key), (keylen))</td></tr>
<tr class="separator:a864d96afe89419821aed4293d979b2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ea46d5db12669bb2687771d094638f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ad4ea46d5db12669bb2687771d094638f">hashlib_MallocContext</a>(size)&#160;&#160;&#160;malloc((size))</td></tr>
<tr class="separator:ad4ea46d5db12669bb2687771d094638f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae34dac71f172c86c1a57258bb0476324"><td class="memItemLeft" align="right" valign="top"><a id="ae34dac71f172c86c1a57258bb0476324"></a>
typedef struct <a class="el" href="struct__sha256__ctx.html">_sha256_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sha256_ctx</b></td></tr>
<tr class="separator:ae34dac71f172c86c1a57258bb0476324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65315f1d62f11ec21b75450e86ce9774"><td class="memItemLeft" align="right" valign="top"><a id="a65315f1d62f11ec21b75450e86ce9774"></a>
typedef struct <a class="el" href="struct__aes__ctx.html">_aes_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><b>aes_ctx</b></td></tr>
<tr class="separator:a65315f1d62f11ec21b75450e86ce9774"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a194ef6b5934dff6dceed4dd819e76340"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a194ef6b5934dff6dceed4dd819e76340">aes_cipher_modes</a> { <a class="el" href="hashlib_8h.html#a194ef6b5934dff6dceed4dd819e76340ad21a3698b98b7368b14ec3d48314a132">AES_MODE_CBC</a>
, <a class="el" href="hashlib_8h.html#a194ef6b5934dff6dceed4dd819e76340a5ecd63cd0bd97d46f273461b6550cb8e">AES_MODE_CTR</a>
 }</td></tr>
<tr class="separator:a194ef6b5934dff6dceed4dd819e76340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9933dec76c43b37331782bdd16ebc4a3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a9933dec76c43b37331782bdd16ebc4a3">aes_padding_schemes</a> { <a class="el" href="hashlib_8h.html#a9933dec76c43b37331782bdd16ebc4a3a7b7b54293004c0ab7a4a1f6a899e53f2">SCHM_PKCS7</a>
, <a class="el" href="hashlib_8h.html#a9933dec76c43b37331782bdd16ebc4a3a1446879dbb5f2f777c955fcf6723ee4a">SCHM_DEFAULT</a> = SCHM_PKCS7
, <a class="el" href="hashlib_8h.html#a9933dec76c43b37331782bdd16ebc4a3a030a31bd034c7d20a80341ede899a6b7">SCHM_ISO2</a>
 }</td></tr>
<tr class="separator:a9933dec76c43b37331782bdd16ebc4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aedfaf159c585059ba8914b59307c21"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a5aedfaf159c585059ba8914b59307c21">_ssl_sig_modes</a> { <a class="el" href="hashlib_8h.html#a5aedfaf159c585059ba8914b59307c21a096ad031cbdad23c8d4053d9b7a3db31">SSLSIG_RSA_SHA256</a>
, <a class="el" href="hashlib_8h.html#a5aedfaf159c585059ba8914b59307c21a3b885e134e618304b93f54b88eff9b25">SSLSIG_ECDSA</a>
 }</td></tr>
<tr class="separator:a5aedfaf159c585059ba8914b59307c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a179d02d08f13b8a2ec239ae3f6fc81de"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a179d02d08f13b8a2ec239ae3f6fc81de">hashlib_SPRNGInit</a> (void)</td></tr>
<tr class="memdesc:a179d02d08f13b8a2ec239ae3f6fc81de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the SPRNG.  <a href="hashlib_8h.html#a179d02d08f13b8a2ec239ae3f6fc81de">More...</a><br /></td></tr>
<tr class="separator:a179d02d08f13b8a2ec239ae3f6fc81de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e253aa114047e5a49af2fd49781559"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ad4e253aa114047e5a49af2fd49781559">hashlib_SPRNGRandom</a> (void)</td></tr>
<tr class="memdesc:ad4e253aa114047e5a49af2fd49781559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random 32-bit number.  <a href="hashlib_8h.html#ad4e253aa114047e5a49af2fd49781559">More...</a><br /></td></tr>
<tr class="separator:ad4e253aa114047e5a49af2fd49781559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0092aa4c122591fae447dda8fa25dfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#aa0092aa4c122591fae447dda8fa25dfc">hashlib_RandomBytes</a> (uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:aa0092aa4c122591fae447dda8fa25dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a buffer to size with random bytes.  <a href="hashlib_8h.html#aa0092aa4c122591fae447dda8fa25dfc">More...</a><br /></td></tr>
<tr class="separator:aa0092aa4c122591fae447dda8fa25dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fa6bc8d3a1156a5734b81f5195afc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ad2fa6bc8d3a1156a5734b81f5195afc4">hashlib_Sha256Init</a> (<a class="el" href="struct__sha256__ctx.html">sha256_ctx</a> *ctx, uint32_t *mbuffer)</td></tr>
<tr class="memdesc:ad2fa6bc8d3a1156a5734b81f5195afc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context initializer for SHA-256. Initializes the given context with the starting state for SHA-256.  <a href="hashlib_8h.html#ad2fa6bc8d3a1156a5734b81f5195afc4">More...</a><br /></td></tr>
<tr class="separator:ad2fa6bc8d3a1156a5734b81f5195afc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed1dabf7c19464f01c87dcb25a77636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#aeed1dabf7c19464f01c87dcb25a77636">hashlib_Sha256Update</a> (<a class="el" href="struct__sha256__ctx.html">sha256_ctx</a> *ctx, const uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:aeed1dabf7c19464f01c87dcb25a77636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the SHA-256 context for the given data.  <a href="hashlib_8h.html#aeed1dabf7c19464f01c87dcb25a77636">More...</a><br /></td></tr>
<tr class="separator:aeed1dabf7c19464f01c87dcb25a77636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27eda4d2b18a026f199abdcab6d1cc8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a27eda4d2b18a026f199abdcab6d1cc8c">hashlib_Sha256Final</a> (<a class="el" href="struct__sha256__ctx.html">sha256_ctx</a> *ctx, uint8_t *digest)</td></tr>
<tr class="memdesc:a27eda4d2b18a026f199abdcab6d1cc8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize Context and Render Digest for SHA-256.  <a href="hashlib_8h.html#a27eda4d2b18a026f199abdcab6d1cc8c">More...</a><br /></td></tr>
<tr class="separator:a27eda4d2b18a026f199abdcab6d1cc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1bd7ec5809afead6583128c9052d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a2c1bd7ec5809afead6583128c9052d8b">hashlib_MGF1Hash</a> (uint8_t *data, size_t datalen, uint8_t *outbuf, size_t outlen)</td></tr>
<tr class="memdesc:a2c1bd7ec5809afead6583128c9052d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary Length Hashing Function.  <a href="hashlib_8h.html#a2c1bd7ec5809afead6583128c9052d8b">More...</a><br /></td></tr>
<tr class="separator:a2c1bd7ec5809afead6583128c9052d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0653a6a286fb1bedfb3e964d36e3b0bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a0653a6a286fb1bedfb3e964d36e3b0bd">hashlib_AESLoadKey</a> (const uint8_t *key, const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *ks, size_t keylen)</td></tr>
<tr class="memdesc:a0653a6a286fb1bedfb3e964d36e3b0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES import key to key schedule context.  <a href="hashlib_8h.html#a0653a6a286fb1bedfb3e964d36e3b0bd">More...</a><br /></td></tr>
<tr class="separator:a0653a6a286fb1bedfb3e964d36e3b0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6987499522b3b85b8ce4b272fadf75dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a6987499522b3b85b8ce4b272fadf75dd">hashlib_AESEncryptBlock</a> (const uint8_t *block_in, uint8_t *block_out, const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *ks)</td></tr>
<tr class="memdesc:a6987499522b3b85b8ce4b272fadf75dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES Single-Block Encryption (ECB mode)  <a href="hashlib_8h.html#a6987499522b3b85b8ce4b272fadf75dd">More...</a><br /></td></tr>
<tr class="separator:a6987499522b3b85b8ce4b272fadf75dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd423839387f0955b6061986c92a2ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a5dd423839387f0955b6061986c92a2ac">hashlib_AESDecryptBlock</a> (const uint8_t *block_in, uint8_t *block_out, const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *ks)</td></tr>
<tr class="memdesc:a5dd423839387f0955b6061986c92a2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES Single-Block Decryption (ECB Mode)  <a href="hashlib_8h.html#a5dd423839387f0955b6061986c92a2ac">More...</a><br /></td></tr>
<tr class="separator:a5dd423839387f0955b6061986c92a2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745c5c4d6bdc248f20b18c7b848d8b6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a745c5c4d6bdc248f20b18c7b848d8b6b">hashlib_AESEncrypt</a> (const uint8_t *plaintext, size_t len, uint8_t *ciphertext, const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *ks, const uint8_t *iv, uint8_t ciphermode)</td></tr>
<tr class="memdesc:a745c5c4d6bdc248f20b18c7b848d8b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">General-Purpose AES Encryption.  <a href="hashlib_8h.html#a745c5c4d6bdc248f20b18c7b848d8b6b">More...</a><br /></td></tr>
<tr class="separator:a745c5c4d6bdc248f20b18c7b848d8b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b904b543405fdf8f283d028ce0d1da7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a2b904b543405fdf8f283d028ce0d1da7">hashlib_AESDecrypt</a> (const uint8_t *ciphertext, size_t len, uint8_t *plaintext, const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *ks, const uint8_t *iv, uint8_t ciphermode)</td></tr>
<tr class="memdesc:a2b904b543405fdf8f283d028ce0d1da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">General-Purpose AES Decryption.  <a href="hashlib_8h.html#a2b904b543405fdf8f283d028ce0d1da7">More...</a><br /></td></tr>
<tr class="separator:a2b904b543405fdf8f283d028ce0d1da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca5ecde1fd675effbc4a29eac35a903"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a6ca5ecde1fd675effbc4a29eac35a903">hashlib_AESOutputMac</a> (const uint8_t *plaintext, size_t len, uint8_t *mac, const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *ks)</td></tr>
<tr class="memdesc:a6ca5ecde1fd675effbc4a29eac35a903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a message authentication code for an AES message.  <a href="hashlib_8h.html#a6ca5ecde1fd675effbc4a29eac35a903">More...</a><br /></td></tr>
<tr class="separator:a6ca5ecde1fd675effbc4a29eac35a903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebac98a8537f3353aac9fbae5ed67f29"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#aebac98a8537f3353aac9fbae5ed67f29">hashlib_AESPadMessage</a> (const uint8_t *plaintext, size_t len, uint8_t *outbuf, uint8_t schm)</td></tr>
<tr class="memdesc:aebac98a8537f3353aac9fbae5ed67f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pads a plaintext according to the specified AES padding scheme.  <a href="hashlib_8h.html#aebac98a8537f3353aac9fbae5ed67f29">More...</a><br /></td></tr>
<tr class="separator:aebac98a8537f3353aac9fbae5ed67f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152d6d62f1a21c97a551cea7e6110e59"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a152d6d62f1a21c97a551cea7e6110e59">hashlib_AESStripPadding</a> (const uint8_t *plaintext, size_t len, uint8_t *outbuf, uint8_t schm)</td></tr>
<tr class="memdesc:a152d6d62f1a21c97a551cea7e6110e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the padding from a message according to the specified AES padding scheme.  <a href="hashlib_8h.html#a152d6d62f1a21c97a551cea7e6110e59">More...</a><br /></td></tr>
<tr class="separator:a152d6d62f1a21c97a551cea7e6110e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c65f6e14ae6287fc2753895ce947be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a52c65f6e14ae6287fc2753895ce947be">hashlib_RSAEncodeOAEP</a> (const uint8_t *plaintext, size_t len, uint8_t *outbuf, size_t modulus_len, const uint8_t *auth)</td></tr>
<tr class="memdesc:a52c65f6e14ae6287fc2753895ce947be"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA-OAEP padding scheme.  <a href="hashlib_8h.html#a52c65f6e14ae6287fc2753895ce947be">More...</a><br /></td></tr>
<tr class="separator:a52c65f6e14ae6287fc2753895ce947be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae575c99825f9b970c3d6f7a6bf552153"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ae575c99825f9b970c3d6f7a6bf552153">hashlib_RSADecodeOAEP</a> (const uint8_t *plaintext, size_t len, uint8_t *outbuf, const uint8_t *auth)</td></tr>
<tr class="memdesc:ae575c99825f9b970c3d6f7a6bf552153"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA-OAEP padding scheme, reverse algorithm.  <a href="hashlib_8h.html#ae575c99825f9b970c3d6f7a6bf552153">More...</a><br /></td></tr>
<tr class="separator:ae575c99825f9b970c3d6f7a6bf552153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01668b3f2dd85fe2f8696673b275b75a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a01668b3f2dd85fe2f8696673b275b75a">hashlib_RSAEncodePSS</a> (const uint8_t *plaintext, size_t len, uint8_t *outbuf, size_t modulus_len, uint8_t *salt)</td></tr>
<tr class="memdesc:a01668b3f2dd85fe2f8696673b275b75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA-PSS padding scheme.  <a href="hashlib_8h.html#a01668b3f2dd85fe2f8696673b275b75a">More...</a><br /></td></tr>
<tr class="separator:a01668b3f2dd85fe2f8696673b275b75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bf91aef912b8346523f37e16d22377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a24bf91aef912b8346523f37e16d22377">hashlib_EraseContext</a> (void *ctx, size_t len)</td></tr>
<tr class="memdesc:a24bf91aef912b8346523f37e16d22377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secure erase context.  <a href="hashlib_8h.html#a24bf91aef912b8346523f37e16d22377">More...</a><br /></td></tr>
<tr class="separator:a24bf91aef912b8346523f37e16d22377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658b0b7f7139a429e3b77a9876e78970"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a658b0b7f7139a429e3b77a9876e78970">hashlib_CompareDigest</a> (const uint8_t *digest1, const uint8_t *digest2, size_t len)</td></tr>
<tr class="memdesc:a658b0b7f7139a429e3b77a9876e78970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secure buffer comparison.  <a href="hashlib_8h.html#a658b0b7f7139a429e3b77a9876e78970">More...</a><br /></td></tr>
<tr class="separator:a658b0b7f7139a429e3b77a9876e78970"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Cryptography Library for the TI-84+ CE. </p>
<p>Provides several cryptographic implementations for the TI-84+ CE graphing calculator.</p><ul>
<li>secure random number generator</li>
<li>SHA-256</li>
<li>AES: CBC, CTR, CBC-MAC</li>
<li>AES Padding: PKCS#7, ISO_M2</li>
<li>RSA public key encryption, modulus &lt;= 2048 bits</li>
<li>RSA Padding: RSA-OAEP via PKCS#7 v2.2, RSA-PSS via PKCS#7 v1.5</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Anthony <em>ACagliano</em> Cagliano </dd>
<dd>
Adam <em>beck</em> Beckingham </dd>
<dd>
commandblockguy </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2841462d8933d0982e3ea13dc5284d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2841462d8933d0982e3ea13dc5284d7c">&#9670;&nbsp;</a></span>AES128_KEYLEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES128_KEYLEN&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the byte-length of a 128-bit AES key </p>

</div>
</div>
<a id="a37ba5c621bf4af2ddcb851e179e21623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ba5c621bf4af2ddcb851e179e21623">&#9670;&nbsp;</a></span>AES192_KEYLEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES192_KEYLEN&#160;&#160;&#160;24</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the byte-length of a 192-bit AES key </p>

</div>
</div>
<a id="a7bab8a778d065da4cc561f4813994f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bab8a778d065da4cc561f4813994f03">&#9670;&nbsp;</a></span>AES256_KEYLEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES256_KEYLEN&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the byte-length of a 256-bit AES key </p>

</div>
</div>
<a id="afab0742642db9c0609c00bf8a54f386f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab0742642db9c0609c00bf8a54f386f">&#9670;&nbsp;</a></span>AES_BLOCKSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES_BLOCKSIZE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the blocksize of the AES cipher. </p>

</div>
</div>
<a id="afc06a029c783f78badc2c26cf6f2297c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc06a029c783f78badc2c26cf6f2297c">&#9670;&nbsp;</a></span>AES_IV_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES_IV_SIZE&#160;&#160;&#160;<a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the length of the AES initalization vector (IV). </p>

</div>
</div>
<a id="acf32bb8a8d871f4cf33f26c8b2a977fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf32bb8a8d871f4cf33f26c8b2a977fb">&#9670;&nbsp;</a></span>AES_MAC_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES_MAC_SIZE&#160;&#160;&#160;<a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the length of the AES CBC-MAC digest. </p>

</div>
</div>
<a id="a89e00bf4bceabd69cff65a5cbf685bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e00bf4bceabd69cff65a5cbf685bd1">&#9670;&nbsp;</a></span>hashlib_AESAuthMacCiphertextLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_AESAuthMacCiphertextLen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len</td><td>)</td>
          <td>&#160;&#160;&#160;	(<a class="el" href="hashlib_8h.html#a140213b514394151a1d6ba410ec32bc4">hashlib_AESCiphertextLen</a>((len)) + <a class="el" href="hashlib_8h.html#acf32bb8a8d871f4cf33f26c8b2a977fb">AES_MAC_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines a macro to return the size of an AES ciphertext with CBC-MAC authentication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is the ciphertext length from the previous macro with an additional block for the CBC-MAC of the ciphertext to be appended. </dd></dl>

</div>
</div>
<a id="abc4277e4f58f162b211ca4c2a38c2a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4277e4f58f162b211ca4c2a38c2a5a">&#9670;&nbsp;</a></span>hashlib_AESAuthSha256CiphertextLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_AESAuthSha256CiphertextLen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len</td><td>)</td>
          <td>&#160;&#160;&#160;	(<a class="el" href="hashlib_8h.html#a140213b514394151a1d6ba410ec32bc4">hashlib_AESCiphertextLen</a>((len)) + <a class="el" href="hashlib_8h.html#af5aa539ae202ddf9e0c9211309869fc8">SHA256_DIGEST_LEN</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines a macro to return the size of an AES ciphertext with SHA-256 authentication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is the ciphertext length from the previous macro with an additional 32 bytes for the SHA-256 of the ciphertext to be appended. </dd></dl>

</div>
</div>
<a id="a140213b514394151a1d6ba410ec32bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140213b514394151a1d6ba410ec32bc4">&#9670;&nbsp;</a></span>hashlib_AESCiphertextLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_AESCiphertextLen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="hashlib_8h.html#af7f9757a799b724cfd578ac0a45f58be">hashlib_AESPaddedSize</a>((len)) + <a class="el" href="hashlib_8h.html#afc06a029c783f78badc2c26cf6f2297c">AES_IV_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines a macro to return the size of an AES ciphertext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the plaintext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is the padded length of the plaintext, plus an additional block for the IV to be prepended. </dd></dl>

</div>
</div>
<a id="a864d96afe89419821aed4293d979b2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864d96afe89419821aed4293d979b2b9">&#9670;&nbsp;</a></span>hashlib_AESKeygen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_AESKeygen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">keylen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="hashlib_8h.html#aa0092aa4c122591fae447dda8fa25dfc">hashlib_RandomBytes</a>((key), (keylen))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines a macro to generate a pseudorandom AES key of a given length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to a buffer to write the key into. </td></tr>
    <tr><td class="paramname">kelen</td><td>The byte length of the key to generate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7f9757a799b724cfd578ac0a45f58be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f9757a799b724cfd578ac0a45f58be">&#9670;&nbsp;</a></span>hashlib_AESPaddedSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_AESPaddedSize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len</td><td>)</td>
          <td>&#160;&#160;&#160;	((((len)%<a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a>)==0) ? (len) + <a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a> : (((len)&gt;&gt;4) + 1)&lt;&lt;4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines a macro to return the padded size of an AES plaintext. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the plaintext. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97c7527aa5efe0f229c45c54ebcc6b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c7527aa5efe0f229c45c54ebcc6b55">&#9670;&nbsp;</a></span>hashlib_FastMemBufferSafe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_FastMemBufferSafe&#160;&#160;&#160;((void*)0xE30A04)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to a region of Fast Memory that is generally safe to use so long as you don't call Libload.. </p><dl class="section warning"><dt>Warning</dt><dd>Fast Memory gets clobbered by LibLoad. Don't keep long-term storage here if you plan to call LibLoad. </dd></dl>

</div>
</div>
<a id="ab981c88a4cd7407b2c4b4bfe86fc021b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab981c88a4cd7407b2c4b4bfe86fc021b">&#9670;&nbsp;</a></span>hashlib_FastMemBufferUnsafe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_FastMemBufferUnsafe&#160;&#160;&#160;((void*)0xE30800)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the start of the region of Fast Memory, including the Safe region as well as an unsafe region used by the library's SPRNG. </p><dl class="section warning"><dt>Warning</dt><dd>Fast Memory gets clobbered by LibLoad. Don't keep long-term storage here if you plan to call LibLoad. </dd>
<dd>
If the SPRNG is run, anything you have stored here will be destroyed. </dd></dl>

</div>
</div>
<a id="ad4ea46d5db12669bb2687771d094638f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ea46d5db12669bb2687771d094638f">&#9670;&nbsp;</a></span>hashlib_MallocContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_MallocContext</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;malloc((size))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically allocates a block of memory to be used for a context or buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the buffer to malloc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <b>malloc</b>. </dd></dl>

</div>
</div>
<a id="af5aa539ae202ddf9e0c9211309869fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aa539ae202ddf9e0c9211309869fc8">&#9670;&nbsp;</a></span>SHA256_DIGEST_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHA256_DIGEST_LEN&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary length of the SHA-256 hash output. </p>

</div>
</div>
<a id="a7a767ce32adaa3ad3e7e4aafff0ae7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a767ce32adaa3ad3e7e4aafff0ae7e3">&#9670;&nbsp;</a></span>SHA256_HEXSTR_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHA256_HEXSTR_LEN&#160;&#160;&#160;(<a class="el" href="hashlib_8h.html#af5aa539ae202ddf9e0c9211309869fc8">SHA256_DIGEST_LEN</a>&lt;&lt;1) + 1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of a string containing the SHA-256 hash. </p>

</div>
</div>
<a id="a939c5eb79064fb776e34fd0c632a588b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939c5eb79064fb776e34fd0c632a588b">&#9670;&nbsp;</a></span>SHA256_MBUFFER_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHA256_MBUFFER_LEN&#160;&#160;&#160;(64 * 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temporary SHA-256 memory buffer. A buffer of this length, in bytes, must be passed to <a class="el" href="hashlib_8h.html#ad2fa6bc8d3a1156a5734b81f5195afc4" title="Context initializer for SHA-256. Initializes the given context with the starting state for SHA-256.">hashlib_Sha256Init()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5aedfaf159c585059ba8914b59307c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aedfaf159c585059ba8914b59307c21">&#9670;&nbsp;</a></span>_ssl_sig_modes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hashlib_8h.html#a5aedfaf159c585059ba8914b59307c21">_ssl_sig_modes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5aedfaf159c585059ba8914b59307c21a096ad031cbdad23c8d4053d9b7a3db31"></a>SSLSIG_RSA_SHA256&#160;</td><td class="fielddoc"><p>RSA with SHA-256 signature algorithm </p>
</td></tr>
<tr><td class="fieldname"><a id="a5aedfaf159c585059ba8914b59307c21a3b885e134e618304b93f54b88eff9b25"></a>SSLSIG_ECDSA&#160;</td><td class="fielddoc"><p>ECDSA (unimplemented, likely a long way off) </p>
</td></tr>
</table>

</div>
</div>
<a id="a194ef6b5934dff6dceed4dd819e76340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194ef6b5934dff6dceed4dd819e76340">&#9670;&nbsp;</a></span>aes_cipher_modes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hashlib_8h.html#a194ef6b5934dff6dceed4dd819e76340">aes_cipher_modes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a194ef6b5934dff6dceed4dd819e76340ad21a3698b98b7368b14ec3d48314a132"></a>AES_MODE_CBC&#160;</td><td class="fielddoc"><p>selects CBC mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a194ef6b5934dff6dceed4dd819e76340a5ecd63cd0bd97d46f273461b6550cb8e"></a>AES_MODE_CTR&#160;</td><td class="fielddoc"><p>selects CTR mode </p>
</td></tr>
</table>

</div>
</div>
<a id="a9933dec76c43b37331782bdd16ebc4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9933dec76c43b37331782bdd16ebc4a3">&#9670;&nbsp;</a></span>aes_padding_schemes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hashlib_8h.html#a9933dec76c43b37331782bdd16ebc4a3">aes_padding_schemes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9933dec76c43b37331782bdd16ebc4a3a7b7b54293004c0ab7a4a1f6a899e53f2"></a>SCHM_PKCS7&#160;</td><td class="fielddoc"><p>PKCS#7 padding | DEFAULT </p>
</td></tr>
<tr><td class="fieldname"><a id="a9933dec76c43b37331782bdd16ebc4a3a1446879dbb5f2f777c955fcf6723ee4a"></a>SCHM_DEFAULT&#160;</td><td class="fielddoc"><p>selects the scheme marked DEFAULT. Using this is recommended in case a change to the standards would set a stronger padding scheme as default </p>
</td></tr>
<tr><td class="fieldname"><a id="a9933dec76c43b37331782bdd16ebc4a3a030a31bd034c7d20a80341ede899a6b7"></a>SCHM_ISO2&#160;</td><td class="fielddoc"><p>ISO-9797 M2 padding </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2b904b543405fdf8f283d028ce0d1da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b904b543405fdf8f283d028ce0d1da7">&#9670;&nbsp;</a></span>hashlib_AESDecrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_AESDecrypt </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ciphermode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General-Purpose AES Decryption. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>Pointer to data to decrypt. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at</td></tr>
    <tr><td class="paramname">ciphertext</td><td>to decrypt. </td></tr>
    <tr><td class="paramname">plaintext</td><td>Pointer to buffer to write decryped data to. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
    <tr><td class="paramname">iv</td><td>Pointer to an initialization vector (a nonce of length equal to the block size). </td></tr>
    <tr><td class="paramname">ciphermode</td><td>The cipher mode to use. Can be either <em>AES_MODE_CBC</em> or <em>AES_MODE_CTR</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>plaintext</b> and <b>ciphertext</b> are aliasable. </dd>
<dd>
<b>IV</b> should be the same as what is used for encryption. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the encryption succeded. False if an error occured. </dd></dl>

</div>
</div>
<a id="a5dd423839387f0955b6061986c92a2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd423839387f0955b6061986c92a2ac">&#9670;&nbsp;</a></span>hashlib_AESDecryptBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_AESDecryptBlock </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>block_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>block_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AES Single-Block Decryption (ECB Mode) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_in</td><td>Pointer to block of data to decrypt. </td></tr>
    <tr><td class="paramname">block_out</td><td>Pointer to buffer to write decrypted block. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>block_in</b> and <b>block_out</b> are aliasable. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>ECB-mode ciphers are insecure (see many-time pad vulnerability). These functions are exposed in case a user wants to construct a cipher mode other than CBC or CTR. Unless you know what you are doing, use <a class="el" href="hashlib_8h.html#a2b904b543405fdf8f283d028ce0d1da7" title="General-Purpose AES Decryption.">hashlib_AESDecrypt()</a> instead. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if encryption succeeded. False if an error occured. </dd></dl>

</div>
</div>
<a id="a745c5c4d6bdc248f20b18c7b848d8b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745c5c4d6bdc248f20b18c7b848d8b6b">&#9670;&nbsp;</a></span>hashlib_AESEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_AESEncrypt </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ciphermode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General-Purpose AES Encryption. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to data to encrypt. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at</td></tr>
    <tr><td class="paramname">plaintext</td><td>to encrypt. </td></tr>
    <tr><td class="paramname">ciphertext</td><td>Pointer to buffer to write encrypted data to. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
    <tr><td class="paramname">iv</td><td>Pointer to an initialization vector (a nonce of length equal to the block size). </td></tr>
    <tr><td class="paramname">ciphermode</td><td>The cipher mode to use. Can be either <em>AES_MODE_CBC</em> or <em>AES_MODE_CTR</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>plaintext</b> and <b>ciphertext</b> are aliasable. </dd>
<dd>
If cipher mode CBC is used, <b>len</b> must be a multiple of the blocksize. You can pass the plaintext through a padding function prior to calling this function. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="hashlib_8h.html#aebac98a8537f3353aac9fbae5ed67f29" title="Pads a plaintext according to the specified AES padding scheme.">hashlib_AESPadMessage()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the encryption succeded. False if an error occured. </dd></dl>

</div>
</div>
<a id="a6987499522b3b85b8ce4b272fadf75dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6987499522b3b85b8ce4b272fadf75dd">&#9670;&nbsp;</a></span>hashlib_AESEncryptBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_AESEncryptBlock </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>block_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>block_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AES Single-Block Encryption (ECB mode) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_in</td><td>Pointer to block of data to encrypt. </td></tr>
    <tr><td class="paramname">block_out</td><td>Pointer to buffer to write encrypted block. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>block_in</b> and <b>block_out</b> are aliasable. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>ECB-mode ciphers are insecure (see many-time pad vulnerability). These functions are exposed in case a user wants to construct a cipher mode other than CBC or CTR. Unless you know what you are doing, use <a class="el" href="hashlib_8h.html#a745c5c4d6bdc248f20b18c7b848d8b6b" title="General-Purpose AES Encryption.">hashlib_AESEncrypt()</a> instead. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if encryption succeeded. False if failed. </dd></dl>

</div>
</div>
<a id="a0653a6a286fb1bedfb3e964d36e3b0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0653a6a286fb1bedfb3e964d36e3b0bd">&#9670;&nbsp;</a></span>hashlib_AESLoadKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_AESLoadKey </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AES import key to key schedule context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to a buffer containing the AES key. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
    <tr><td class="paramname">keylen</td><td>The size, in bytes, of the key to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the key was successfully loaded. False otherwise. </dd></dl>

</div>
</div>
<a id="a6ca5ecde1fd675effbc4a29eac35a903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca5ecde1fd675effbc4a29eac35a903">&#9670;&nbsp;</a></span>hashlib_AESOutputMac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_AESOutputMac </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__aes__ctx.html">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a message authentication code for an AES message. </p>
<p>The MAC is a tag equal in length to the AES block size computed by passing the plaintext through the CBC-MAC algorithm with a constant IV.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to data to generate a MAC for. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at</td></tr>
    <tr><td class="paramname">plaintext</td><td>to generate a MAC for. </td></tr>
    <tr><td class="paramname">mac</td><td>Pointer to a buffer to write the MAC to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>CBC-MAC requires padding, as it uses CBC mode. You can use the <a class="el" href="hashlib_8h.html#aebac98a8537f3353aac9fbae5ed67f29" title="Pads a plaintext according to the specified AES padding scheme.">hashlib_AESPadMessage()</a> padding function. Padding mode ISO-9791 M2 is preferred for CBC-MAC, but either can be used. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not use the same AES key/key schedule for authentication and encryption. This exposes attack vectors. Use different key schedules. </dd>
<dd>
For the most secure authenticated encryption scheme, use "encrypt-then-MAC". This means that you encrypt first, then you return a MAC or hash of the ciphertext and any associated un-encrypted metadata (such as the IV). While some authentication schemes do use "MAC-then-encrypt", there are more attack vectors against that. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the MAC generation succeeded. False if an error occured. </dd></dl>

</div>
</div>
<a id="aebac98a8537f3353aac9fbae5ed67f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebac98a8537f3353aac9fbae5ed67f29">&#9670;&nbsp;</a></span>hashlib_AESPadMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashlib_AESPadMessage </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>schm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pads a plaintext according to the specified AES padding scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to buffer containing the data to pad. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at</td></tr>
    <tr><td class="paramname">plaintext</td><td>to pad. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer to write padded data. </td></tr>
    <tr><td class="paramname">schm</td><td>The AES padding scheme to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>plaintext</b> and <b>outbuf</b> are aliasable. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The padded length of the message. </dd></dl>

</div>
</div>
<a id="a152d6d62f1a21c97a551cea7e6110e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152d6d62f1a21c97a551cea7e6110e59">&#9670;&nbsp;</a></span>hashlib_AESStripPadding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashlib_AESStripPadding </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>schm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips the padding from a message according to the specified AES padding scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to buffer containing the data to strip. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at</td></tr>
    <tr><td class="paramname">plaintext</td><td>to strip. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer to write stripped data. </td></tr>
    <tr><td class="paramname">schm</td><td>The AES padding scheme to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>plaintext</b> and <b>outbuf</b> are aliasable. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the message with padding removed. </dd></dl>

</div>
</div>
<a id="a658b0b7f7139a429e3b77a9876e78970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658b0b7f7139a429e3b77a9876e78970">&#9670;&nbsp;</a></span>hashlib_CompareDigest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hashlib_CompareDigest </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>digest1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>digest2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Secure buffer comparison. </p>
<p>Evaluates the equality of two buffers using a method that offers resistance to timing attacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digest1</td><td>The first buffer to compare. </td></tr>
    <tr><td class="paramname">digest2</td><td>The second buffer to compare. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the buffers were equal. False if not equal. </dd></dl>

</div>
</div>
<a id="a24bf91aef912b8346523f37e16d22377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bf91aef912b8346523f37e16d22377">&#9670;&nbsp;</a></span>hashlib_EraseContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_EraseContext </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Secure erase context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to any context or buffer you want to erase. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes at <b>ctx</b> to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is advised to call this on every cryptographic context and encryption buffer used. </dd></dl>

</div>
</div>
<a id="a2c1bd7ec5809afead6583128c9052d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1bd7ec5809afead6583128c9052d8b">&#9670;&nbsp;</a></span>hashlib_MGF1Hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_MGF1Hash </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arbitrary Length Hashing Function. </p>
<p>Computes SHA-256 of the data and with a counter appended to generate a hash of arbitrary length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to data to hash. </td></tr>
    <tr><td class="paramname">datalen</td><td>Number of bytes at <b>data</b> to hash. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer to write hash output to. </td></tr>
    <tr><td class="paramname">outlen</td><td>Number of bytes to write to <b>outbuf</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>outbuf</b> must be at least <b>outlen</b> bytes large. </dd></dl>

</div>
</div>
<a id="aa0092aa4c122591fae447dda8fa25dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0092aa4c122591fae447dda8fa25dfc">&#9670;&nbsp;</a></span>hashlib_RandomBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_RandomBytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a buffer to size with random bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer to write random data to. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>buffer</b> must be at least <b>size</b> bytes large. </dd></dl>

</div>
</div>
<a id="ae575c99825f9b970c3d6f7a6bf552153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae575c99825f9b970c3d6f7a6bf552153">&#9670;&nbsp;</a></span>hashlib_RSADecodeOAEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashlib_RSADecodeOAEP </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>auth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSA-OAEP padding scheme, reverse algorithm. </p>
<p>Reverses the RSA-OAEP padding scheme as indicated in PKCS#1 v2.2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to a buffer containing the data to OAEP-decode. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at <b>plaintext</b> to decode. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer large enough to hold the decoded data. </td></tr>
    <tr><td class="paramname">auth</td><td>Pointer to an authentication string (similar to a password) to include in the encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>outbuf</b> must be at least <b>len-34</b> bytes large. </dd>
<dd>
<b>auth</b> Both sender and reciever must know this string if one is provided. Pass NULL to omit. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The decoded length of the plaintext. </dd></dl>

</div>
</div>
<a id="a52c65f6e14ae6287fc2753895ce947be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c65f6e14ae6287fc2753895ce947be">&#9670;&nbsp;</a></span>hashlib_RSAEncodeOAEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashlib_RSAEncodeOAEP </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>modulus_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>auth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSA-OAEP padding scheme. </p>
<p>Applies the RSA-OAEP padding scheme as indicated in PKCS#1 v2.2. This is intended for use prior to RSA encryption. </p><div class="fragment"><div class="line">| &lt;-------------------------------- modulus size ---------------------------------&gt; |</div>
<div class="line">|-- 0x00 --|-- salt --|-- auth hash --|-- 0x00...padding --|-- 0x01 --|-- message --|</div>
<div class="line">           |          |-------------------------------------------------------------|</div>
<div class="line">           |                                       |</div>
<div class="line">           | ------------ MGF1-SHA256 -----------&gt;XOR</div>
<div class="line">           |                                       |</div>
<div class="line">          XOR &lt;----------- MGF1-SHA256 ------------|</div>
<div class="line">           |                                       |</div>
<div class="line">|-- 0x00 --|-- msalt --|---------- masked message, padding, and auth hash ----------|</div>
<div class="line">|&lt;-------------------------------- modulus size ----------------------------------&gt; |</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to a buffer containing the data to OAEP-encode. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at <b>plaintext</b> to encode. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer large enough to hold the padded data. </td></tr>
    <tr><td class="paramname">modulus_len</td><td>The byte length of the modulus to pad for. </td></tr>
    <tr><td class="paramname">auth</td><td>Pointer to an authentication string (similar to a password) to include in the encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>outbuf</b> must be at least <b>modulus_len</b> bytes large. </dd>
<dd>
<b>auth</b> both sender and receiver must know this string. Pass NULL to omit. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The padded length of the plaintext. </dd></dl>

</div>
</div>
<a id="a01668b3f2dd85fe2f8696673b275b75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01668b3f2dd85fe2f8696673b275b75a">&#9670;&nbsp;</a></span>hashlib_RSAEncodePSS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashlib_RSAEncodePSS </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>modulus_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>salt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSA-PSS padding scheme. </p>
<p>Applies the RSA-PSS padding scheme as indicated in PKCS#1 v1.5. </p><div class="fragment"><div class="line">|- Message -|  ---------------------- SHA-256 ----------------------&gt;|</div>
<div class="line">                                                                     |</div>
<div class="line">|-- 0x00 padding --|-- 0x01 --|-- salt --|  |-- 8 bytes 0x00 --|-- mHash --|-- salt --|</div>
<div class="line">|----------------------------------------|  |-----------------------------------------|</div>
<div class="line">*DB                  |                      *Mprime              |</div>
<div class="line">                     |                                        SHA-256</div>
<div class="line">                    XOR &lt;------------- MGF1-SHA256 --------------|</div>
<div class="line">                     |                                           |</div>
<div class="line">                     |                           &lt; ------------- |</div>
<div class="line">                     |                           |</div>
<div class="line">|-------------- masked DB --------------|-- Mprime Hash --|-- 0xbc --|</div>
<div class="line">|-------------------------- modulus size ----------------------------|</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to buffer containing data to encode. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at</td></tr>
    <tr><td class="paramname">plaintext</td><td>to encode. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer to write encoded plaintext to. </td></tr>
    <tr><td class="paramname">modulus_len</td><td>The length of the modulus to pad for. </td></tr>
    <tr><td class="paramname">salt</td><td>A buffer filled with random bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>outbuf</b> must be at least <b>modulus_len</b> bytes large. </dd>
<dd>
If you are trying to generate a signature, pass NULL to generate a new salt. </dd>
<dd>
If you are trying to validate a signature, use hashlib_SSLVerifySignature(). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the padded length of the plaintext. </dd></dl>

</div>
</div>
<a id="a27eda4d2b18a026f199abdcab6d1cc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27eda4d2b18a026f199abdcab6d1cc8c">&#9670;&nbsp;</a></span>hashlib_Sha256Final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_Sha256Final </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__sha256__ctx.html">sha256_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize Context and Render Digest for SHA-256. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to a SHA-256 context. </td></tr>
    <tr><td class="paramname">digest</td><td>Pointer to a buffer to write the hash to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>digest</b> must be at least 32 bytes large. </dd></dl>

</div>
</div>
<a id="ad2fa6bc8d3a1156a5734b81f5195afc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fa6bc8d3a1156a5734b81f5195afc4">&#9670;&nbsp;</a></span>hashlib_Sha256Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_Sha256Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__sha256__ctx.html">sha256_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mbuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context initializer for SHA-256. Initializes the given context with the starting state for SHA-256. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to a SHA-256 context. </td></tr>
    <tr><td class="paramname">mbuffer</td><td>Pointer to a temporary memory buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>mbuffer</b> must be at least <b>SHA256_MBUFFER_LEN</b> bytes large. </dd></dl>

</div>
</div>
<a id="aeed1dabf7c19464f01c87dcb25a77636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed1dabf7c19464f01c87dcb25a77636">&#9670;&nbsp;</a></span>hashlib_Sha256Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_Sha256Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__sha256__ctx.html">sha256_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the SHA-256 context for the given data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to a SHA-256 context. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to data to hash. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes at</td></tr>
    <tr><td class="paramname">buf</td><td>to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>You must call hashlib_SHA256Init() first or your hash state will be invalid. </dd></dl>

</div>
</div>
<a id="a179d02d08f13b8a2ec239ae3f6fc81de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179d02d08f13b8a2ec239ae3f6fc81de">&#9670;&nbsp;</a></span>hashlib_SPRNGInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hashlib_SPRNGInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the SPRNG. </p>
<p>The SPRNG is initialized by polling the 512-bytes from address 0xD65800 to 0xD66000. This region consists of unmapped memory that contains bus noise. Each bit in that region is polled 1024 times and the address with the bit that is the least biased is selected. That will be the byte the SPRNG uses to generate entropy. </p><dl class="section return"><dt>Returns</dt><dd>The unmapped address selected for use generating entropy </dd></dl>

</div>
</div>
<a id="ad4e253aa114047e5a49af2fd49781559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e253aa114047e5a49af2fd49781559">&#9670;&nbsp;</a></span>hashlib_SPRNGRandom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hashlib_SPRNGRandom </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random 32-bit number. </p>
<ul>
<li>Calls <a class="el" href="hashlib_8h.html#a179d02d08f13b8a2ec239ae3f6fc81de" title="Initializes the SPRNG.">hashlib_SPRNGInit()</a> if it hasn't already been done.</li>
<li>Populates a 119-byte entropy pool by xor'ing 7 distinct reads from the unmapped address together per byte.</li>
<li>Hashes the entropy pool using SHA-256.</li>
<li>Breaks the SHA-256 hash into 8-byte blocks, then xor's all 8 bytes each block together, leaving four (4) composite bytes.</li>
<li>Returns the 4-byte (32-bit) composite as a random number.. <dl class="section return"><dt>Returns</dt><dd>A random unsigned 32-bit integer. </dd></dl>
</li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
