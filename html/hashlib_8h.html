<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hashlib CE: hashlib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hashlib CE
   &#160;<span id="projectnumber">6</span>
   </div>
   <div id="projectbrief">A cryptography library for the TI-84+ CE</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hashlib.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Cryptography Library for the TI-84+ CE.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="hashlib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__sha256__ctx.html">_sha256_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__hmac__ctx.html">_hmac_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__aes__ctx.html">_aes_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a97c7527aa5efe0f229c45c54ebcc6b55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a97c7527aa5efe0f229c45c54ebcc6b55">hashlib_FastMemBufferSafe</a>&#160;&#160;&#160;((void*)0xE30A04)</td></tr>
<tr class="separator:a97c7527aa5efe0f229c45c54ebcc6b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab981c88a4cd7407b2c4b4bfe86fc021b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ab981c88a4cd7407b2c4b4bfe86fc021b">hashlib_FastMemBufferUnsafe</a>&#160;&#160;&#160;((void*)0xE30800)</td></tr>
<tr class="separator:ab981c88a4cd7407b2c4b4bfe86fc021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aa539ae202ddf9e0c9211309869fc8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#af5aa539ae202ddf9e0c9211309869fc8">SHA256_DIGEST_LEN</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:af5aa539ae202ddf9e0c9211309869fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7781b6f83e2f311020d3b926b70743ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a7781b6f83e2f311020d3b926b70743ed">SHA256_HEXDIGEST_LEN</a>&#160;&#160;&#160;(<a class="el" href="hashlib_8h.html#af5aa539ae202ddf9e0c9211309869fc8">SHA256_DIGEST_LEN</a>&lt;&lt;1) + 1</td></tr>
<tr class="separator:a7781b6f83e2f311020d3b926b70743ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab0742642db9c0609c00bf8a54f386f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:afab0742642db9c0609c00bf8a54f386f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2d58d8dd281845fdc027b499dea89d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a6c2d58d8dd281845fdc027b499dea89d">AES_IVSIZE</a>&#160;&#160;&#160;<a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a></td></tr>
<tr class="separator:a6c2d58d8dd281845fdc027b499dea89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2841462d8933d0982e3ea13dc5284d7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a2841462d8933d0982e3ea13dc5284d7c">AES128_KEYLEN</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a2841462d8933d0982e3ea13dc5284d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ba5c621bf4af2ddcb851e179e21623"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a37ba5c621bf4af2ddcb851e179e21623">AES192_KEYLEN</a>&#160;&#160;&#160;24</td></tr>
<tr class="separator:a37ba5c621bf4af2ddcb851e179e21623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bab8a778d065da4cc561f4813994f03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a7bab8a778d065da4cc561f4813994f03">AES256_KEYLEN</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a7bab8a778d065da4cc561f4813994f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd39d64a42b6a8d56b0b18efc9d164c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a2bd39d64a42b6a8d56b0b18efc9d164c">hashlib_AESCiphertextSize</a>(len)&#160;&#160;&#160;	((((len)%<a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a>)==0) ? (len) + <a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a> : (((len)&gt;&gt;4) + 1)&lt;&lt;4)</td></tr>
<tr class="separator:a2bd39d64a42b6a8d56b0b18efc9d164c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfa78156f62c2e87f7af3a8533304b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a1bfa78156f62c2e87f7af3a8533304b1">hashlib_AESCiphertextIVSize</a>(len)&#160;&#160;&#160;(<a class="el" href="hashlib_8h.html#a2bd39d64a42b6a8d56b0b18efc9d164c">hashlib_AESCiphertextSize</a>((len)) + <a class="el" href="hashlib_8h.html#a6c2d58d8dd281845fdc027b499dea89d">AES_IVSIZE</a>)</td></tr>
<tr class="separator:a1bfa78156f62c2e87f7af3a8533304b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864d96afe89419821aed4293d979b2b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a864d96afe89419821aed4293d979b2b9">hashlib_AESKeygen</a>(key,  keylen)&#160;&#160;&#160;<a class="el" href="hashlib_8h.html#ab5d6193b9c9dd748e3ae79f241010354">hashlib_RandomBytes</a>((key), (keylen))</td></tr>
<tr class="separator:a864d96afe89419821aed4293d979b2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ea46d5db12669bb2687771d094638f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ad4ea46d5db12669bb2687771d094638f">hashlib_MallocContext</a>(size)&#160;&#160;&#160;malloc((size))</td></tr>
<tr class="separator:ad4ea46d5db12669bb2687771d094638f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a53df9e7d871973d59c7b58a6c3963c5d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__sha256__ctx.html">_sha256_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a53df9e7d871973d59c7b58a6c3963c5d">sha256_ctx</a></td></tr>
<tr class="separator:a53df9e7d871973d59c7b58a6c3963c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d813300476744f01319600478572f62"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__hmac__ctx.html">_hmac_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a8d813300476744f01319600478572f62">hmac_ctx</a></td></tr>
<tr class="separator:a8d813300476744f01319600478572f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa188bc2768a3b7aa6ad73cb2c77819e0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__aes__ctx.html">_aes_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a></td></tr>
<tr class="separator:aa188bc2768a3b7aa6ad73cb2c77819e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a194ef6b5934dff6dceed4dd819e76340"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a194ef6b5934dff6dceed4dd819e76340">aes_cipher_modes</a> { <a class="el" href="hashlib_8h.html#a194ef6b5934dff6dceed4dd819e76340ad21a3698b98b7368b14ec3d48314a132">AES_MODE_CBC</a>
, <a class="el" href="hashlib_8h.html#a194ef6b5934dff6dceed4dd819e76340a5ecd63cd0bd97d46f273461b6550cb8e">AES_MODE_CTR</a>
 }</td></tr>
<tr class="separator:a194ef6b5934dff6dceed4dd819e76340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9933dec76c43b37331782bdd16ebc4a3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a9933dec76c43b37331782bdd16ebc4a3">aes_padding_schemes</a> { <a class="el" href="hashlib_8h.html#a9933dec76c43b37331782bdd16ebc4a3a7b7b54293004c0ab7a4a1f6a899e53f2">SCHM_PKCS7</a>
, <a class="el" href="hashlib_8h.html#a9933dec76c43b37331782bdd16ebc4a3a1446879dbb5f2f777c955fcf6723ee4a">SCHM_DEFAULT</a> = SCHM_PKCS7
, <a class="el" href="hashlib_8h.html#a9933dec76c43b37331782bdd16ebc4a3a030a31bd034c7d20a80341ede899a6b7">SCHM_ISO2</a>
 }</td></tr>
<tr class="separator:a9933dec76c43b37331782bdd16ebc4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2e64abcc4317e3143fb820f21c3bfd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfd">aes_error_t</a> { <br />
&#160;&#160;<a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfdaacf07636102724d2a7913911b0cf74b2">AES_OK</a>
, <a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfda6d39b280aea9d8d62d126eef05d271db">AES_INVALID_ARG</a>
, <a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfdaae5e9a591aeda666b0e425d9a05834e3">AES_INVALID_MSG</a>
, <a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfdad2b49ffeabf14aaf47db3d1bad18f84e">AES_INVALID_CIPHERMODE</a>
, <br />
&#160;&#160;<a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfda47bbd593fc3bdb7758a790bab86b41d9">AES_INVALID_PADDINGMODE</a>
, <a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfdaba928751c773ffa0287e47e1f86eae8b">AES_INVALID_CIPHERTEXT</a>
<br />
 }</td></tr>
<tr class="separator:aeb2e64abcc4317e3143fb820f21c3bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7508a7cdffede3d44a818dd4a154bf95"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a7508a7cdffede3d44a818dd4a154bf95">ssl_sig_modes</a> { <a class="el" href="hashlib_8h.html#a7508a7cdffede3d44a818dd4a154bf95a096ad031cbdad23c8d4053d9b7a3db31">SSLSIG_RSA_SHA256</a>
, <a class="el" href="hashlib_8h.html#a7508a7cdffede3d44a818dd4a154bf95a3b885e134e618304b93f54b88eff9b25">SSLSIG_ECDSA</a>
 }</td></tr>
<tr class="separator:a7508a7cdffede3d44a818dd4a154bf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0486449f609d0e485bad091a671d9294"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294">rsa_error_t</a> { <br />
&#160;&#160;<a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294a2cafdb683e1870a33bcb821420626cae">RSA_OK</a>
, <a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294aab9ab38286c4180a1aa9f6e8df42e5db">RSA_INVALID_ARG</a>
, <a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294aedeb18a96b96e292369abed5b2f0a271">RSA_INVALID_MSG</a>
, <a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294a843ec210de66176ef63e2d2b8ebdeb65">RSA_INVALID_MODULUS</a>
, <br />
&#160;&#160;<a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294a43eadc89540121b902e02afabc7a7eb9">RSA_ENCODING_ERROR</a>
<br />
 }</td></tr>
<tr class="separator:a0486449f609d0e485bad091a671d9294"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9e1bc8499482660a4163b5f025023493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a9e1bc8499482660a4163b5f025023493">hashlib_SPRNGInit</a> (void)</td></tr>
<tr class="memdesc:a9e1bc8499482660a4163b5f025023493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the SPRNG.  <a href="hashlib_8h.html#a9e1bc8499482660a4163b5f025023493">More...</a><br /></td></tr>
<tr class="separator:a9e1bc8499482660a4163b5f025023493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e253aa114047e5a49af2fd49781559"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ad4e253aa114047e5a49af2fd49781559">hashlib_SPRNGRandom</a> (void)</td></tr>
<tr class="memdesc:ad4e253aa114047e5a49af2fd49781559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random 32-bit number.  <a href="hashlib_8h.html#ad4e253aa114047e5a49af2fd49781559">More...</a><br /></td></tr>
<tr class="separator:ad4e253aa114047e5a49af2fd49781559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d6193b9c9dd748e3ae79f241010354"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ab5d6193b9c9dd748e3ae79f241010354">hashlib_RandomBytes</a> (void *buffer, size_t size)</td></tr>
<tr class="memdesc:ab5d6193b9c9dd748e3ae79f241010354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a buffer to size with random bytes.  <a href="hashlib_8h.html#ab5d6193b9c9dd748e3ae79f241010354">More...</a><br /></td></tr>
<tr class="separator:ab5d6193b9c9dd748e3ae79f241010354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac901e0546d0cb0c218fedbe4a43fc005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ac901e0546d0cb0c218fedbe4a43fc005">hashlib_Sha256Init</a> (<a class="el" href="hashlib_8h.html#a53df9e7d871973d59c7b58a6c3963c5d">sha256_ctx</a> *ctx)</td></tr>
<tr class="memdesc:ac901e0546d0cb0c218fedbe4a43fc005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context initializer for SHA-256. Initializes the given context with the starting state for SHA-256.  <a href="hashlib_8h.html#ac901e0546d0cb0c218fedbe4a43fc005">More...</a><br /></td></tr>
<tr class="separator:ac901e0546d0cb0c218fedbe4a43fc005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4075cc831db34aa54acc825849ac8dd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a4075cc831db34aa54acc825849ac8dd7">hashlib_Sha256Update</a> (<a class="el" href="hashlib_8h.html#a53df9e7d871973d59c7b58a6c3963c5d">sha256_ctx</a> *ctx, const void *data, size_t len)</td></tr>
<tr class="memdesc:a4075cc831db34aa54acc825849ac8dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the SHA-256 context for the given data.  <a href="hashlib_8h.html#a4075cc831db34aa54acc825849ac8dd7">More...</a><br /></td></tr>
<tr class="separator:a4075cc831db34aa54acc825849ac8dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cae93c13fd3323059f3ca2afe4f93b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a7cae93c13fd3323059f3ca2afe4f93b4">hashlib_Sha256Final</a> (<a class="el" href="hashlib_8h.html#a53df9e7d871973d59c7b58a6c3963c5d">sha256_ctx</a> *ctx, void *digest)</td></tr>
<tr class="memdesc:a7cae93c13fd3323059f3ca2afe4f93b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize Context and Render Digest for SHA-256.  <a href="hashlib_8h.html#a7cae93c13fd3323059f3ca2afe4f93b4">More...</a><br /></td></tr>
<tr class="separator:a7cae93c13fd3323059f3ca2afe4f93b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8745d49bced3eb01f9b41329e82299c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ae8745d49bced3eb01f9b41329e82299c">hashlib_MGF1Hash</a> (const void *data, size_t datalen, void *outbuf, size_t outlen)</td></tr>
<tr class="memdesc:ae8745d49bced3eb01f9b41329e82299c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary Length Hashing Function.  <a href="hashlib_8h.html#ae8745d49bced3eb01f9b41329e82299c">More...</a><br /></td></tr>
<tr class="separator:ae8745d49bced3eb01f9b41329e82299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e269917830fb7802cea159baadf079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a86e269917830fb7802cea159baadf079">hashlib_HMACSha256Init</a> (<a class="el" href="hashlib_8h.html#a8d813300476744f01319600478572f62">hmac_ctx</a> *ctx, const void *key, size_t keylen)</td></tr>
<tr class="memdesc:a86e269917830fb7802cea159baadf079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context Initializer for SHA-256 HMAC.  <a href="hashlib_8h.html#a86e269917830fb7802cea159baadf079">More...</a><br /></td></tr>
<tr class="separator:a86e269917830fb7802cea159baadf079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f72de7b1416b6a30b8a2a1198d0098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#af7f72de7b1416b6a30b8a2a1198d0098">hashlib_HMACSha256Update</a> (<a class="el" href="hashlib_8h.html#a8d813300476744f01319600478572f62">hmac_ctx</a> *ctx, const void *data, size_t len)</td></tr>
<tr class="memdesc:af7f72de7b1416b6a30b8a2a1198d0098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the SHA-256 HMAC context for the given data.  <a href="hashlib_8h.html#af7f72de7b1416b6a30b8a2a1198d0098">More...</a><br /></td></tr>
<tr class="separator:af7f72de7b1416b6a30b8a2a1198d0098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daab1377ef405c96825e11d481fa27e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a3daab1377ef405c96825e11d481fa27e">hashlib_HMACSha256Final</a> (<a class="el" href="hashlib_8h.html#a8d813300476744f01319600478572f62">hmac_ctx</a> *ctx, void *output)</td></tr>
<tr class="memdesc:a3daab1377ef405c96825e11d481fa27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize Context and Render Digest for SHA-256 HMAC.  <a href="hashlib_8h.html#a3daab1377ef405c96825e11d481fa27e">More...</a><br /></td></tr>
<tr class="separator:a3daab1377ef405c96825e11d481fa27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0e235ac96b3f4c4a8e6d037efc053f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a5e0e235ac96b3f4c4a8e6d037efc053f">hashlib_HMACSha256Reset</a> (<a class="el" href="hashlib_8h.html#a8d813300476744f01319600478572f62">hmac_ctx</a> *ctx)</td></tr>
<tr class="memdesc:a5e0e235ac96b3f4c4a8e6d037efc053f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the SHA-256 HMAC context to its state after a call to <a class="el" href="hashlib_8h.html#a86e269917830fb7802cea159baadf079" title="Context Initializer for SHA-256 HMAC.">hashlib_HMACSha256Init()</a>  <a href="hashlib_8h.html#a5e0e235ac96b3f4c4a8e6d037efc053f">More...</a><br /></td></tr>
<tr class="separator:a5e0e235ac96b3f4c4a8e6d037efc053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b32359ef23fb02d2ff2c0bb629f80b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#aa2b32359ef23fb02d2ff2c0bb629f80b">hashlib_PBKDF2</a> (const char *password, size_t passlen, void *key, const void *salt, size_t saltlen, size_t rounds, size_t keylen)</td></tr>
<tr class="memdesc:aa2b32359ef23fb02d2ff2c0bb629f80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Password-Based Key Derivation Function (via SHA-256 HMAC)  <a href="hashlib_8h.html#aa2b32359ef23fb02d2ff2c0bb629f80b">More...</a><br /></td></tr>
<tr class="separator:aa2b32359ef23fb02d2ff2c0bb629f80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c38b8e422c65a946ed0bb433e2dc3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a72c38b8e422c65a946ed0bb433e2dc3c">hashlib_AESLoadKey</a> (const void *key, const <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *ks, size_t keylen)</td></tr>
<tr class="memdesc:a72c38b8e422c65a946ed0bb433e2dc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES import key to key schedule context.  <a href="hashlib_8h.html#a72c38b8e422c65a946ed0bb433e2dc3c">More...</a><br /></td></tr>
<tr class="separator:a72c38b8e422c65a946ed0bb433e2dc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1206cd9923279d06108d363a9881f79b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfd">aes_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a1206cd9923279d06108d363a9881f79b">hashlib_AESEncrypt</a> (const void *plaintext, size_t len, void *ciphertext, const <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *ks, const void *iv, uint8_t ciphermode, uint8_t paddingmode)</td></tr>
<tr class="memdesc:a1206cd9923279d06108d363a9881f79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">General-Purpose AES Encryption.  <a href="hashlib_8h.html#a1206cd9923279d06108d363a9881f79b">More...</a><br /></td></tr>
<tr class="separator:a1206cd9923279d06108d363a9881f79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9213710a9ffc0358220c8aa11f395bb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfd">aes_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a9213710a9ffc0358220c8aa11f395bb2">hashlib_AESDecrypt</a> (const void *ciphertext, size_t len, void *plaintext, const <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *ks, const void *iv, uint8_t ciphermode, uint8_t paddingmode)</td></tr>
<tr class="memdesc:a9213710a9ffc0358220c8aa11f395bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">General-Purpose AES Decryption.  <a href="hashlib_8h.html#a9213710a9ffc0358220c8aa11f395bb2">More...</a><br /></td></tr>
<tr class="separator:a9213710a9ffc0358220c8aa11f395bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104fbe2d5097020e89cca09af982dea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfd">aes_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a104fbe2d5097020e89cca09af982dea6">hashlib_AESAuthEncrypt</a> (const void *plaintext, size_t len, void *ciphertext, <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *key, const void *iv, uint8_t ciphermode, size_t encryption_offset, size_t encryption_len)</td></tr>
<tr class="memdesc:a104fbe2d5097020e89cca09af982dea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Authenticated AES Encryption.  <a href="hashlib_8h.html#a104fbe2d5097020e89cca09af982dea6">More...</a><br /></td></tr>
<tr class="separator:a104fbe2d5097020e89cca09af982dea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7609df266293fd2fcc98279be119b8e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfd">aes_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a7609df266293fd2fcc98279be119b8e3">hashlib_AESAuthDecrypt</a> (const void *ciphertext, size_t len, void *plaintext, <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *key, const void *iv, uint8_t ciphermode, size_t decryption_offset, size_t decryption_len)</td></tr>
<tr class="memdesc:a7609df266293fd2fcc98279be119b8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Authenticated AES Decryption.  <a href="hashlib_8h.html#a7609df266293fd2fcc98279be119b8e3">More...</a><br /></td></tr>
<tr class="separator:a7609df266293fd2fcc98279be119b8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb66f3d3437a9f5a16e9191a4d46d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294">rsa_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a5fb66f3d3437a9f5a16e9191a4d46d74">hashlib_RSAEncrypt</a> (const void *msg, size_t msglen, void *ciphertext, const void *pubkey, size_t keylen)</td></tr>
<tr class="memdesc:a5fb66f3d3437a9f5a16e9191a4d46d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA Encryption.  <a href="hashlib_8h.html#a5fb66f3d3437a9f5a16e9191a4d46d74">More...</a><br /></td></tr>
<tr class="separator:a5fb66f3d3437a9f5a16e9191a4d46d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9751a5d91dc4cfcdb90de0518a79f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ada9751a5d91dc4cfcdb90de0518a79f6">hashlib_SSLVerifySignature</a> (const void *ca_pubkey, size_t keysize, const void *cert, size_t certlen, uint8_t sig_alg)</td></tr>
<tr class="memdesc:ada9751a5d91dc4cfcdb90de0518a79f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSL Certificate Signature Verification.  <a href="hashlib_8h.html#ada9751a5d91dc4cfcdb90de0518a79f6">More...</a><br /></td></tr>
<tr class="separator:ada9751a5d91dc4cfcdb90de0518a79f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef56629c9316e022d77dfc4623cffeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#afef56629c9316e022d77dfc4623cffeb">hashlib_DigestToHexStr</a> (const void *digest, size_t len, char *hexstr)</td></tr>
<tr class="memdesc:afef56629c9316e022d77dfc4623cffeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a digest to a valid hex string.  <a href="hashlib_8h.html#afef56629c9316e022d77dfc4623cffeb">More...</a><br /></td></tr>
<tr class="separator:afef56629c9316e022d77dfc4623cffeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bf91aef912b8346523f37e16d22377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a24bf91aef912b8346523f37e16d22377">hashlib_EraseContext</a> (void *ctx, size_t len)</td></tr>
<tr class="memdesc:a24bf91aef912b8346523f37e16d22377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secure erase context.  <a href="hashlib_8h.html#a24bf91aef912b8346523f37e16d22377">More...</a><br /></td></tr>
<tr class="separator:a24bf91aef912b8346523f37e16d22377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2188204b9ee6024de788c221a33863"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#afa2188204b9ee6024de788c221a33863">hashlib_CompareDigest</a> (const void *digest1, const void *digest2, size_t len)</td></tr>
<tr class="memdesc:afa2188204b9ee6024de788c221a33863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secure buffer comparison.  <a href="hashlib_8h.html#afa2188204b9ee6024de788c221a33863">More...</a><br /></td></tr>
<tr class="separator:afa2188204b9ee6024de788c221a33863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceec2ce59159467d7f78142834360d63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#aceec2ce59159467d7f78142834360d63">hashlib_ReverseEndianness</a> (const void *in, void *out, size_t len)</td></tr>
<tr class="memdesc:aceec2ce59159467d7f78142834360d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the endianness of a buffer.  <a href="hashlib_8h.html#aceec2ce59159467d7f78142834360d63">More...</a><br /></td></tr>
<tr class="separator:aceec2ce59159467d7f78142834360d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b8f870cb2e787f0cce92f24c61f070"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ab5b8f870cb2e787f0cce92f24c61f070">hashlib_AESEncryptBlock</a> (const void *block_in, void *block_out, const <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *ks)</td></tr>
<tr class="memdesc:ab5b8f870cb2e787f0cce92f24c61f070"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES Single-Block Encryption (ECB mode)  <a href="hashlib_8h.html#ab5b8f870cb2e787f0cce92f24c61f070">More...</a><br /></td></tr>
<tr class="separator:ab5b8f870cb2e787f0cce92f24c61f070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12af5da58cdba7080c6101d1fc0542b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a12af5da58cdba7080c6101d1fc0542b2">hashlib_AESDecryptBlock</a> (const void *block_in, void *block_out, const <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *ks)</td></tr>
<tr class="memdesc:a12af5da58cdba7080c6101d1fc0542b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES Single-Block Decryption (ECB Mode)  <a href="hashlib_8h.html#a12af5da58cdba7080c6101d1fc0542b2">More...</a><br /></td></tr>
<tr class="separator:a12af5da58cdba7080c6101d1fc0542b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266d90502e38e3bf17c2a2fc5be02388"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a266d90502e38e3bf17c2a2fc5be02388">hashlib_AESPadMessage</a> (const void *plaintext, size_t len, void *outbuf, uint8_t schm)</td></tr>
<tr class="memdesc:a266d90502e38e3bf17c2a2fc5be02388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pads a plaintext according to the specified AES padding scheme.  <a href="hashlib_8h.html#a266d90502e38e3bf17c2a2fc5be02388">More...</a><br /></td></tr>
<tr class="separator:a266d90502e38e3bf17c2a2fc5be02388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c578a28a265740178be49fce6a8d13d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a7c578a28a265740178be49fce6a8d13d">hashlib_AESStripPadding</a> (const void *plaintext, size_t len, void *outbuf, uint8_t schm)</td></tr>
<tr class="memdesc:a7c578a28a265740178be49fce6a8d13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the padding from a message according to the specified AES padding scheme.  <a href="hashlib_8h.html#a7c578a28a265740178be49fce6a8d13d">More...</a><br /></td></tr>
<tr class="separator:a7c578a28a265740178be49fce6a8d13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861a2527b90e2b2412ea715c07f7014d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a861a2527b90e2b2412ea715c07f7014d">hashlib_RSAEncodeOAEP</a> (const void *plaintext, size_t len, void *outbuf, size_t modulus_len, const void *auth)</td></tr>
<tr class="memdesc:a861a2527b90e2b2412ea715c07f7014d"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA-OAEP padding scheme.  <a href="hashlib_8h.html#a861a2527b90e2b2412ea715c07f7014d">More...</a><br /></td></tr>
<tr class="separator:a861a2527b90e2b2412ea715c07f7014d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f471e18b48999cdd4aa61e19cfbfa7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#ab5f471e18b48999cdd4aa61e19cfbfa7">hashlib_RSADecodeOAEP</a> (const void *plaintext, size_t len, void *outbuf, const void *auth)</td></tr>
<tr class="memdesc:ab5f471e18b48999cdd4aa61e19cfbfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA-OAEP padding scheme, reverse algorithm.  <a href="hashlib_8h.html#ab5f471e18b48999cdd4aa61e19cfbfa7">More...</a><br /></td></tr>
<tr class="separator:ab5f471e18b48999cdd4aa61e19cfbfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63abd0c582f39039601eb341d5c9cb35"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a63abd0c582f39039601eb341d5c9cb35">hashlib_RSAEncodePSS</a> (const void *plaintext, size_t len, void *outbuf, size_t modulus_len, void *salt)</td></tr>
<tr class="memdesc:a63abd0c582f39039601eb341d5c9cb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA-PSS padding scheme.  <a href="hashlib_8h.html#a63abd0c582f39039601eb341d5c9cb35">More...</a><br /></td></tr>
<tr class="separator:a63abd0c582f39039601eb341d5c9cb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f95403c8ef99fd39d5fcec33cb0ab3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a07f95403c8ef99fd39d5fcec33cb0ab3">hashlib_RSAVerifyPSS</a> (const void *data, size_t len, const void *expected, size_t modulus_len)</td></tr>
<tr class="memdesc:a07f95403c8ef99fd39d5fcec33cb0ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA-PSS verification.  <a href="hashlib_8h.html#a07f95403c8ef99fd39d5fcec33cb0ab3">More...</a><br /></td></tr>
<tr class="separator:a07f95403c8ef99fd39d5fcec33cb0ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382c457497fc3f8f8dac7f9dfb296a71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294">rsa_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashlib_8h.html#a382c457497fc3f8f8dac7f9dfb296a71">hashlib_RSAAuthEncrypt</a> (const void *msg, size_t msglen, void *ciphertext, const void *pubkey, size_t keylen)</td></tr>
<tr class="memdesc:a382c457497fc3f8f8dac7f9dfb296a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Authenticated RSA Encryption.  <a href="hashlib_8h.html#a382c457497fc3f8f8dac7f9dfb296a71">More...</a><br /></td></tr>
<tr class="separator:a382c457497fc3f8f8dac7f9dfb296a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Cryptography Library for the TI-84+ CE. </p>
<p>Provides several cryptographic implementations for the TI-84+ CE graphing calculator.</p><ul>
<li>secure random number generator</li>
<li>SHA-256, SHA-256 (HMAC)</li>
<li>PBKDF2_HMAC</li>
<li>AES: CBC and CTR cipher modes</li>
<li>AES Padding: PKCS#7, ISO-9797 M2</li>
<li>RSA public key encryption, 1024 bits &lt;= modulus &lt;= 2048 bits</li>
<li>RSA Padding: RSA-OAEP via PKCS#7 v2.2, RSA-PSS via PKCS#7 v1.5</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Anthony <em>ACagliano</em> Cagliano </dd>
<dd>
Adam <em>beck</em> Beckingham </dd>
<dd>
commandblockguy </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a97c7527aa5efe0f229c45c54ebcc6b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c7527aa5efe0f229c45c54ebcc6b55">&#9670;&nbsp;</a></span>hashlib_FastMemBufferSafe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_FastMemBufferSafe&#160;&#160;&#160;((void*)0xE30A04)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to a region of Fast Memory that is generally safe to use so long as you don't call Libload.. </p><dl class="section warning"><dt>Warning</dt><dd>Fast Memory gets clobbered by LibLoad. Don't keep long-term storage here if you plan to call LibLoad. </dd></dl>

</div>
</div>
<a id="ab981c88a4cd7407b2c4b4bfe86fc021b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab981c88a4cd7407b2c4b4bfe86fc021b">&#9670;&nbsp;</a></span>hashlib_FastMemBufferUnsafe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_FastMemBufferUnsafe&#160;&#160;&#160;((void*)0xE30800)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the start of the region of Fast Memory, including the Safe region as well as an unsafe region used by the library's SPRNG. </p><dl class="section warning"><dt>Warning</dt><dd>Fast Memory gets clobbered by LibLoad. Don't keep long-term storage here if you plan to call LibLoad. </dd>
<dd>
If the SPRNG is run, anything you have stored here will be destroyed. </dd></dl>

</div>
</div>
<a id="af5aa539ae202ddf9e0c9211309869fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aa539ae202ddf9e0c9211309869fc8">&#9670;&nbsp;</a></span>SHA256_DIGEST_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHA256_DIGEST_LEN&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary length of the SHA-256 hash output. </p>

</div>
</div>
<a id="a7781b6f83e2f311020d3b926b70743ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7781b6f83e2f311020d3b926b70743ed">&#9670;&nbsp;</a></span>SHA256_HEXDIGEST_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHA256_HEXDIGEST_LEN&#160;&#160;&#160;(<a class="el" href="hashlib_8h.html#af5aa539ae202ddf9e0c9211309869fc8">SHA256_DIGEST_LEN</a>&lt;&lt;1) + 1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of a string containing the SHA-256 hash. </p>

</div>
</div>
<a id="afab0742642db9c0609c00bf8a54f386f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab0742642db9c0609c00bf8a54f386f">&#9670;&nbsp;</a></span>AES_BLOCKSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES_BLOCKSIZE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the blocksize of the AES cipher. </p>

</div>
</div>
<a id="a6c2d58d8dd281845fdc027b499dea89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2d58d8dd281845fdc027b499dea89d">&#9670;&nbsp;</a></span>AES_IVSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES_IVSIZE&#160;&#160;&#160;<a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the length of the AES initalization vector (IV). </p>

</div>
</div>
<a id="a2841462d8933d0982e3ea13dc5284d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2841462d8933d0982e3ea13dc5284d7c">&#9670;&nbsp;</a></span>AES128_KEYLEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES128_KEYLEN&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the byte-length of a 128-bit AES key </p>

</div>
</div>
<a id="a37ba5c621bf4af2ddcb851e179e21623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ba5c621bf4af2ddcb851e179e21623">&#9670;&nbsp;</a></span>AES192_KEYLEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES192_KEYLEN&#160;&#160;&#160;24</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the byte-length of a 192-bit AES key </p>

</div>
</div>
<a id="a7bab8a778d065da4cc561f4813994f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bab8a778d065da4cc561f4813994f03">&#9670;&nbsp;</a></span>AES256_KEYLEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AES256_KEYLEN&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the byte-length of a 256-bit AES key </p>

</div>
</div>
<a id="a2bd39d64a42b6a8d56b0b18efc9d164c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd39d64a42b6a8d56b0b18efc9d164c">&#9670;&nbsp;</a></span>hashlib_AESCiphertextSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_AESCiphertextSize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len</td><td>)</td>
          <td>&#160;&#160;&#160;	((((len)%<a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a>)==0) ? (len) + <a class="el" href="hashlib_8h.html#afab0742642db9c0609c00bf8a54f386f">AES_BLOCKSIZE</a> : (((len)&gt;&gt;4) + 1)&lt;&lt;4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines a macro to return the size of an AES ciphertext given a plaintext length. Does not include space for an IV-prepend. See hashlib_AESCiphertextIVLen() for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the plaintext. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bfa78156f62c2e87f7af3a8533304b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfa78156f62c2e87f7af3a8533304b1">&#9670;&nbsp;</a></span>hashlib_AESCiphertextIVSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_AESCiphertextIVSize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="hashlib_8h.html#a2bd39d64a42b6a8d56b0b18efc9d164c">hashlib_AESCiphertextSize</a>((len)) + <a class="el" href="hashlib_8h.html#a6c2d58d8dd281845fdc027b499dea89d">AES_IVSIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines a macro to return the size of an AES ciphertext with with an extra block added for the IV.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the plaintext. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a864d96afe89419821aed4293d979b2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864d96afe89419821aed4293d979b2b9">&#9670;&nbsp;</a></span>hashlib_AESKeygen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_AESKeygen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">keylen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="hashlib_8h.html#ab5d6193b9c9dd748e3ae79f241010354">hashlib_RandomBytes</a>((key), (keylen))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines a macro to generate a pseudorandom AES key of a given length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to a buffer to write the key into. </td></tr>
    <tr><td class="paramname">keylen</td><td>The byte length of the key to generate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>key</b> must be at least <b>keylen</b> bytes large. </dd></dl>

</div>
</div>
<a id="ad4ea46d5db12669bb2687771d094638f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ea46d5db12669bb2687771d094638f">&#9670;&nbsp;</a></span>hashlib_MallocContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hashlib_MallocContext</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;malloc((size))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically allocates a block of memory to be used for a context or buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the buffer to malloc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <b>malloc</b>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a53df9e7d871973d59c7b58a6c3963c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53df9e7d871973d59c7b58a6c3963c5d">&#9670;&nbsp;</a></span>sha256_ctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashlib_8h.html#a53df9e7d871973d59c7b58a6c3963c5d">sha256_ctx</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines hash-state data for an instance of SHA-256. </p><dl class="section note"><dt>Note</dt><dd>If you are hashing multiple data streams concurrently, allocate a seperate context for each. </dd></dl>

</div>
</div>
<a id="a8d813300476744f01319600478572f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d813300476744f01319600478572f62">&#9670;&nbsp;</a></span>hmac_ctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashlib_8h.html#a8d813300476744f01319600478572f62">hmac_ctx</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines hash-state data for an instance of SHA-256-HMAC. </p><dl class="section note"><dt>Note</dt><dd>If you are hashing multiple data streams concurrently, allocate a seperate context for each. </dd></dl>

</div>
</div>
<a id="aa188bc2768a3b7aa6ad73cb2c77819e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa188bc2768a3b7aa6ad73cb2c77819e0">&#9670;&nbsp;</a></span>aes_ctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores AES key instance data: key size and round keys generated from an AES key. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a194ef6b5934dff6dceed4dd819e76340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194ef6b5934dff6dceed4dd819e76340">&#9670;&nbsp;</a></span>aes_cipher_modes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hashlib_8h.html#a194ef6b5934dff6dceed4dd819e76340">aes_cipher_modes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported AES cipher modes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a194ef6b5934dff6dceed4dd819e76340ad21a3698b98b7368b14ec3d48314a132"></a>AES_MODE_CBC&#160;</td><td class="fielddoc"><p>selects CBC mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a194ef6b5934dff6dceed4dd819e76340a5ecd63cd0bd97d46f273461b6550cb8e"></a>AES_MODE_CTR&#160;</td><td class="fielddoc"><p>selects CTR mode </p>
</td></tr>
</table>

</div>
</div>
<a id="a9933dec76c43b37331782bdd16ebc4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9933dec76c43b37331782bdd16ebc4a3">&#9670;&nbsp;</a></span>aes_padding_schemes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hashlib_8h.html#a9933dec76c43b37331782bdd16ebc4a3">aes_padding_schemes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported AES padding schemes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9933dec76c43b37331782bdd16ebc4a3a7b7b54293004c0ab7a4a1f6a899e53f2"></a>SCHM_PKCS7&#160;</td><td class="fielddoc"><p>PKCS#7 padding | DEFAULT </p>
</td></tr>
<tr><td class="fieldname"><a id="a9933dec76c43b37331782bdd16ebc4a3a1446879dbb5f2f777c955fcf6723ee4a"></a>SCHM_DEFAULT&#160;</td><td class="fielddoc"><p>selects the scheme marked DEFAULT. Using this is recommended in case a change to the standards would set a stronger padding scheme as default </p>
</td></tr>
<tr><td class="fieldname"><a id="a9933dec76c43b37331782bdd16ebc4a3a030a31bd034c7d20a80341ede899a6b7"></a>SCHM_ISO2&#160;</td><td class="fielddoc"><p>ISO-9797 M2 padding </p>
</td></tr>
</table>

</div>
</div>
<a id="aeb2e64abcc4317e3143fb820f21c3bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2e64abcc4317e3143fb820f21c3bfd">&#9670;&nbsp;</a></span>aes_error_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfd">aes_error_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AES Error Codes (returned by hashlib_AESEncrypt/Decrypt) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aeb2e64abcc4317e3143fb820f21c3bfdaacf07636102724d2a7913911b0cf74b2"></a>AES_OK&#160;</td><td class="fielddoc"><p>AES operation completed successfully </p>
</td></tr>
<tr><td class="fieldname"><a id="aeb2e64abcc4317e3143fb820f21c3bfda6d39b280aea9d8d62d126eef05d271db"></a>AES_INVALID_ARG&#160;</td><td class="fielddoc"><p>AES operation failed, bad argument </p>
</td></tr>
<tr><td class="fieldname"><a id="aeb2e64abcc4317e3143fb820f21c3bfdaae5e9a591aeda666b0e425d9a05834e3"></a>AES_INVALID_MSG&#160;</td><td class="fielddoc"><p>AES operation failed, message invalid </p>
</td></tr>
<tr><td class="fieldname"><a id="aeb2e64abcc4317e3143fb820f21c3bfdad2b49ffeabf14aaf47db3d1bad18f84e"></a>AES_INVALID_CIPHERMODE&#160;</td><td class="fielddoc"><p>AES operation failed, cipher mode undefined </p>
</td></tr>
<tr><td class="fieldname"><a id="aeb2e64abcc4317e3143fb820f21c3bfda47bbd593fc3bdb7758a790bab86b41d9"></a>AES_INVALID_PADDINGMODE&#160;</td><td class="fielddoc"><p>AES operation failed, padding mode undefined </p>
</td></tr>
<tr><td class="fieldname"><a id="aeb2e64abcc4317e3143fb820f21c3bfdaba928751c773ffa0287e47e1f86eae8b"></a>AES_INVALID_CIPHERTEXT&#160;</td><td class="fielddoc"><p>AES operation failed, ciphertext error </p>
</td></tr>
</table>

</div>
</div>
<a id="a7508a7cdffede3d44a818dd4a154bf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7508a7cdffede3d44a818dd4a154bf95">&#9670;&nbsp;</a></span>ssl_sig_modes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hashlib_8h.html#a7508a7cdffede3d44a818dd4a154bf95">ssl_sig_modes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SSL signature algorithms </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7508a7cdffede3d44a818dd4a154bf95a096ad031cbdad23c8d4053d9b7a3db31"></a>SSLSIG_RSA_SHA256&#160;</td><td class="fielddoc"><p>RSA with SHA-256 signature algorithm </p>
</td></tr>
<tr><td class="fieldname"><a id="a7508a7cdffede3d44a818dd4a154bf95a3b885e134e618304b93f54b88eff9b25"></a>SSLSIG_ECDSA&#160;</td><td class="fielddoc"><p>ECDSA (unimplemented, likely a long way off) </p>
</td></tr>
</table>

</div>
</div>
<a id="a0486449f609d0e485bad091a671d9294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0486449f609d0e485bad091a671d9294">&#9670;&nbsp;</a></span>rsa_error_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294">rsa_error_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RSA Encryption Error Codes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0486449f609d0e485bad091a671d9294a2cafdb683e1870a33bcb821420626cae"></a>RSA_OK&#160;</td><td class="fielddoc"><p>RSA encryption completed successfully </p>
</td></tr>
<tr><td class="fieldname"><a id="a0486449f609d0e485bad091a671d9294aab9ab38286c4180a1aa9f6e8df42e5db"></a>RSA_INVALID_ARG&#160;</td><td class="fielddoc"><p>RSA encryption failed, bad argument </p>
</td></tr>
<tr><td class="fieldname"><a id="a0486449f609d0e485bad091a671d9294aedeb18a96b96e292369abed5b2f0a271"></a>RSA_INVALID_MSG&#160;</td><td class="fielddoc"><p>RSA encryption failed, bad msg or msg too long </p>
</td></tr>
<tr><td class="fieldname"><a id="a0486449f609d0e485bad091a671d9294a843ec210de66176ef63e2d2b8ebdeb65"></a>RSA_INVALID_MODULUS&#160;</td><td class="fielddoc"><p>RSA encryption failed, modulus invalid </p>
</td></tr>
<tr><td class="fieldname"><a id="a0486449f609d0e485bad091a671d9294a43eadc89540121b902e02afabc7a7eb9"></a>RSA_ENCODING_ERROR&#160;</td><td class="fielddoc"><p>RSA encryption failed, OAEP encoding error </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9e1bc8499482660a4163b5f025023493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1bc8499482660a4163b5f025023493">&#9670;&nbsp;</a></span>hashlib_SPRNGInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_SPRNGInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the SPRNG. </p>
<p>Secure Psuedorandom Number Generator (SPRNG)</p>
<p>Many of the psuedorandom number generators (PRNGs) you find in computers and even the one within the C toolchain for the CE are insecure for cryptographic purposes. They produce statistical randomness, but the state is generally seeded using a value such as rtc_Time(). If an adversary reconstructs the seed, every output of the PRNG becomes computable with little effort. These types of PRNGs are called deterministic algorithms&ndash;given the input, the output is predictable. These PRNGs work for games and other applications where the illusion of randomness is sufficient, but they are not safe for cryptography.</p>
<p>A secure PRNG is an random number generator that is not only statistically random, but also passes the next-bit and state compromise tests. The <em>next-bit test</em> is defined like so: given the prior output of the PRNG (bits 0=&gt;i), the next bit (i+1) of the output cannot be predicted by a polynomial-time statistical test with a probability non-negligibly greater than 50%. In simpler terms, a secure PRNG must be unpredictable, or "entropic". The <em>state compromise test</em> means that an adversary gaining knowledge of the initial state of the PRNG does not gain any information about its output.</p>
<p>The PRNG previded by HASHLIB solves both tests like so: (next-bit) &lt;&gt; The PRNG's output is derived from a 119-byte entropy pool created by reading data from the most entropic byte located within floating memory on the device. &lt;&gt; The "entropic byte" is a byte containing a bit that that, out of 1024 test reads, has the closest to a 50/50 split between 1's and 0's. &lt;&gt; The byte containing that bit is read in xor mode seven times per byte to offset any hardware-based correlation between subsequent reads from the entropic byte. &lt;&gt; The entropy pool is then run through a cryptographic hash to spread that entropy evenly through the returned random value. &lt;&gt; The PRNG produces 96.51 bits of entropy per 32 bit number returned. &lt;&gt; Assertion: A source of randomness with sufficient entropy passed through a cryptographic hash will produce output that passes all statistical randomness tests as well as the next-bit test. (state compromise) &lt;&gt; The entropy pool is discarded after it is used once, and a new pool is generated for the next random number. &lt;&gt; ^ This means that the prior state has no bearing on the next output of the PRNG. &lt;&gt; The PRNG destroys its own state after the random number is generated so that the state used to generate it does not persist in memory. </p>
<p>The SPRNG is initialized by polling the 512-bytes from address 0xD65800 to 0xD66000. This region consists of unmapped memory that contains bus noise. Each bit in that region is polled 1024 times and the address with the bit that is the least biased is selected. That will be the byte the SPRNG uses to generate entropy. </p>

</div>
</div>
<a id="ad4e253aa114047e5a49af2fd49781559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e253aa114047e5a49af2fd49781559">&#9670;&nbsp;</a></span>hashlib_SPRNGRandom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hashlib_SPRNGRandom </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random 32-bit number. </p>
<ul>
<li>Calls <a class="el" href="hashlib_8h.html#a9e1bc8499482660a4163b5f025023493" title="Initializes the SPRNG.">hashlib_SPRNGInit()</a> if it hasn't already been done.</li>
<li>Populates a 119-byte entropy pool by xor'ing 7 distinct reads from the unmapped address together per byte.</li>
<li>Hashes the entropy pool using SHA-256.</li>
<li>Breaks the SHA-256 hash into 8-byte blocks, then xor's all 8 bytes each block together, leaving four (4) composite bytes.</li>
<li>Returns the 4-byte (32-bit) composite as a random number.. <dl class="section return"><dt>Returns</dt><dd>A random unsigned 32-bit integer. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ab5d6193b9c9dd748e3ae79f241010354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d6193b9c9dd748e3ae79f241010354">&#9670;&nbsp;</a></span>hashlib_RandomBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_RandomBytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a buffer to size with random bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer to write random data to. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>buffer</b> must be at least <b>size</b> bytes large. </dd></dl>

</div>
</div>
<a id="ac901e0546d0cb0c218fedbe4a43fc005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac901e0546d0cb0c218fedbe4a43fc005">&#9670;&nbsp;</a></span>hashlib_Sha256Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_Sha256Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashlib_8h.html#a53df9e7d871973d59c7b58a6c3963c5d">sha256_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context initializer for SHA-256. Initializes the given context with the starting state for SHA-256. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to a SHA-256 context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4075cc831db34aa54acc825849ac8dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4075cc831db34aa54acc825849ac8dd7">&#9670;&nbsp;</a></span>hashlib_Sha256Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_Sha256Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashlib_8h.html#a53df9e7d871973d59c7b58a6c3963c5d">sha256_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the SHA-256 context for the given data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to a SHA-256 context. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to data to hash. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes at <b>data</b> to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>You must call <a class="el" href="hashlib_8h.html#ac901e0546d0cb0c218fedbe4a43fc005" title="Context initializer for SHA-256. Initializes the given context with the starting state for SHA-256.">hashlib_Sha256Init()</a> first or your hash state will be invalid. </dd></dl>

</div>
</div>
<a id="a7cae93c13fd3323059f3ca2afe4f93b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cae93c13fd3323059f3ca2afe4f93b4">&#9670;&nbsp;</a></span>hashlib_Sha256Final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_Sha256Final </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashlib_8h.html#a53df9e7d871973d59c7b58a6c3963c5d">sha256_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize Context and Render Digest for SHA-256. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to a SHA-256 context. </td></tr>
    <tr><td class="paramname">digest</td><td>Pointer to a buffer to write the hash to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>digest</b> must be at least 32 bytes large. </dd></dl>

</div>
</div>
<a id="ae8745d49bced3eb01f9b41329e82299c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8745d49bced3eb01f9b41329e82299c">&#9670;&nbsp;</a></span>hashlib_MGF1Hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_MGF1Hash </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arbitrary Length Hashing Function. </p>
<p>Computes SHA-256 of the data with a counter appended to generate a hash of arbitrary length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to data to hash. </td></tr>
    <tr><td class="paramname">datalen</td><td>Number of bytes at <b>data</b> to hash. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer to write hash output to. </td></tr>
    <tr><td class="paramname">outlen</td><td>Number of bytes to write to <b>outbuf</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>outbuf</b> must be at least <b>outlen</b> bytes large. </dd></dl>

</div>
</div>
<a id="a86e269917830fb7802cea159baadf079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e269917830fb7802cea159baadf079">&#9670;&nbsp;</a></span>hashlib_HMACSha256Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_HMACSha256Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashlib_8h.html#a8d813300476744f01319600478572f62">hmac_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context Initializer for SHA-256 HMAC. </p>
<p>Initializes the given context with the starting state for SHA-256 HMAC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to a SHA-256 HMAC context. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer to an authentication key used to initialize the base SHA-256 context. </td></tr>
    <tr><td class="paramname">keylen</td><td>Length of <b>key</b>, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7f72de7b1416b6a30b8a2a1198d0098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f72de7b1416b6a30b8a2a1198d0098">&#9670;&nbsp;</a></span>hashlib_HMACSha256Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_HMACSha256Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashlib_8h.html#a8d813300476744f01319600478572f62">hmac_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the SHA-256 HMAC context for the given data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to a SHA-256 HMAC context. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to data to hash. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes at <b>data</b> to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>You must call <a class="el" href="hashlib_8h.html#a86e269917830fb7802cea159baadf079" title="Context Initializer for SHA-256 HMAC.">hashlib_HMACSha256Init()</a> first or your hash state will be invalid. </dd></dl>

</div>
</div>
<a id="a3daab1377ef405c96825e11d481fa27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3daab1377ef405c96825e11d481fa27e">&#9670;&nbsp;</a></span>hashlib_HMACSha256Final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_HMACSha256Final </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashlib_8h.html#a8d813300476744f01319600478572f62">hmac_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize Context and Render Digest for SHA-256 HMAC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to a SHA-256 HMAC context. </td></tr>
    <tr><td class="paramname">digest</td><td>Pointer to a buffer to write the hash to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>digest</b> must be at least 32 bytes large. </dd></dl>

</div>
</div>
<a id="a5e0e235ac96b3f4c4a8e6d037efc053f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0e235ac96b3f4c4a8e6d037efc053f">&#9670;&nbsp;</a></span>hashlib_HMACSha256Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_HMACSha256Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashlib_8h.html#a8d813300476744f01319600478572f62">hmac_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the SHA-256 HMAC context to its state after a call to <a class="el" href="hashlib_8h.html#a86e269917830fb7802cea159baadf079" title="Context Initializer for SHA-256 HMAC.">hashlib_HMACSha256Init()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to a SHA-256 HMAC context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls the SHA-256 Init function, then Updates() the context with the ipad. </dd></dl>

</div>
</div>
<a id="aa2b32359ef23fb02d2ff2c0bb629f80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b32359ef23fb02d2ff2c0bb629f80b">&#9670;&nbsp;</a></span>hashlib_PBKDF2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_PBKDF2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>passlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>salt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>saltlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Password-Based Key Derivation Function (via SHA-256 HMAC) </p>
<p>Computes a key derived from a password, a 16-byte salt, and a given number of rounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Pointer to a string containing the password to derive a key from. </td></tr>
    <tr><td class="paramname">passlen</td><td>The length of the password (in bytes). </td></tr>
    <tr><td class="paramname">key</td><td>The buffer to write the key to. Must be at least <b>keylen</b> bytes large. </td></tr>
    <tr><td class="paramname">salt</td><td>A psuedo-random string to use when computing the key. </td></tr>
    <tr><td class="paramname">saltlen</td><td>The length of the salt to use (in bytes). </td></tr>
    <tr><td class="paramname">rounds</td><td>The number of times to iterate the SHA-256 function per 32-byte block of <b>keylen</b>. </td></tr>
    <tr><td class="paramname">keylen</td><td>The length of the key to generate (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Standards recommend a salt of at least 128 bits (16 bytes). </dd>
<dd>
<b>rounds</b> is used to increase the cost (computational time) of generating a key. What makes password- hashing algorithms secure is the time needed to generate a rainbow table attack against it. More rounds means a more secure key, but more time spent generating it. Current cryptography standards recommend in excess of 1000 rounds but that may not be feasible on the CE. </dd></dl>

</div>
</div>
<a id="a72c38b8e422c65a946ed0bb433e2dc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c38b8e422c65a946ed0bb433e2dc3c">&#9670;&nbsp;</a></span>hashlib_AESLoadKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_AESLoadKey </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AES import key to key schedule context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to a buffer containing the AES key. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
    <tr><td class="paramname">keylen</td><td>The size, in bytes, of the key to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the key was successfully loaded. False otherwise. </dd></dl>

</div>
</div>
<a id="a1206cd9923279d06108d363a9881f79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1206cd9923279d06108d363a9881f79b">&#9670;&nbsp;</a></span>hashlib_AESEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfd">aes_error_t</a> hashlib_AESEncrypt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ciphermode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>paddingmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General-Purpose AES Encryption. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to data to encrypt. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at <b>plaintext</b> to encrypt. This can be the output of <a class="el" href="hashlib_8h.html#a2bd39d64a42b6a8d56b0b18efc9d164c">hashlib_AESCiphertextSize()</a>. </td></tr>
    <tr><td class="paramname">ciphertext</td><td>Pointer to buffer to write encrypted data to. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
    <tr><td class="paramname">iv</td><td>Pointer to an initialization vector (a nonce of length equal to the block size). </td></tr>
    <tr><td class="paramname">ciphermode</td><td>The cipher mode to use. Can be either <em>AES_MODE_CBC</em> or <em>AES_MODE_CTR</em>. </td></tr>
    <tr><td class="paramname">paddingmode</td><td>The padding mode to use. Choose one of the padding modes in <b>enum</b> aes_padding_schemes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>ciphertext</b> should large enough to hold the encrypted message. For CBC mode, this is the smallest multiple of the blocksize that will hold the plaintext, plus 1 block if the blocksize divides the plaintext evenly. For CTR mode, this is the same size as the plaintext. </dd>
<dd>
<b>plaintext</b> and <b>ciphertext</b> are aliasable. </dd>
<dd>
<b>IV</b> is not written to the ciphertext buffer by this function, only the encrypted message. However, if your ciphertext buffer is large enough, you can do the following to get the IV prepended to the ciphertext. Otherwise you will have to join the IV and the ciphertext into a single larger buffer before sending it through whatever networking protocol you use. <div class="fragment"><div class="line"><a class="code" href="hashlib_8h.html#a1206cd9923279d06108d363a9881f79b">hashlib_AESEncrypt</a>(plaintext, len, &amp;ciphertext[AES_IV_SIZE], ks, iv, &lt;cipher_mode&gt;, &lt;padding_mode&gt;);</div>
<div class="line">memcpy(ciphertext, iv, AES_IV_SIZE);</div>
<div class="line">send_packet(ciphertext);</div>
<div class="ttc" id="ahashlib_8h_html_a1206cd9923279d06108d363a9881f79b"><div class="ttname"><a href="hashlib_8h.html#a1206cd9923279d06108d363a9881f79b">hashlib_AESEncrypt</a></div><div class="ttdeci">aes_error_t hashlib_AESEncrypt(const void *plaintext, size_t len, void *ciphertext, const aes_ctx *ks, const void *iv, uint8_t ciphermode, uint8_t paddingmode)</div><div class="ttdoc">General-Purpose AES Encryption.</div></div>
</div><!-- fragment --> This will require a buffer at least as large as the size returned by <a class="el" href="hashlib_8h.html#a1bfa78156f62c2e87f7af3a8533304b1">hashlib_AESCiphertextIVSize()</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>aes_error_t </dd></dl>

</div>
</div>
<a id="a9213710a9ffc0358220c8aa11f395bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9213710a9ffc0358220c8aa11f395bb2">&#9670;&nbsp;</a></span>hashlib_AESDecrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfd">aes_error_t</a> hashlib_AESDecrypt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ciphermode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>paddingmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General-Purpose AES Decryption. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>Pointer to data to decrypt. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at <b>ciphertext</b> to decrypt. </td></tr>
    <tr><td class="paramname">plaintext</td><td>Pointer to buffer to write decryped data to. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
    <tr><td class="paramname">iv</td><td>Pointer to an initialization vector (a nonce of length equal to the block size). </td></tr>
    <tr><td class="paramname">ciphermode</td><td>The cipher mode to use. Can be either <em>AES_MODE_CBC</em> or <em>AES_MODE_CTR</em>. </td></tr>
    <tr><td class="paramname">paddingmode</td><td>The padding mode to use. Choose one of the padding modes in <b>enum</b> aes_padding_schemes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>plaintext</b> and <b>ciphertext</b> are aliasable. </dd>
<dd>
<b>IV</b> should be the same as what is used for encryption. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>aes_error_t </dd></dl>

</div>
</div>
<a id="a104fbe2d5097020e89cca09af982dea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104fbe2d5097020e89cca09af982dea6">&#9670;&nbsp;</a></span>hashlib_AESAuthEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfd">aes_error_t</a> hashlib_AESAuthEncrypt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ciphermode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encryption_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encryption_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Authenticated AES Encryption. </p>
<p>Performs an authenticated encryption of the given message. Supports partial encryption via the <b>encryption_offset</b> and <b>encryption_len</b> parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to the data to encrypt and authenticate. </td></tr>
    <tr><td class="paramname">len</td><td>The size of the plaintext to encrypt and authenticate. </td></tr>
    <tr><td class="paramname">ciphertext</td><td>The buffer to write the authenticated encryption to. Must be large enough to hold the ciphertext (including any padding) as well as the SHA-256 hash. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
    <tr><td class="paramname">iv</td><td>Pointer to an initialization vector (a nonce of length equal to the block size). </td></tr>
    <tr><td class="paramname">ciphermode</td><td>The cipher mode to use. Can be either <em>AES_MODE_CBC</em> or <em>AES_MODE_CTR</em>. </td></tr>
    <tr><td class="paramname">encryption_offset</td><td>The offset from the start of the plaintext to begin encryption. This is useful if you have control bytes or metadata that should not be encrypted. </td></tr>
    <tr><td class="paramname">encryption_len</td><td>The size of the data to be encrypted. This is useful if you have trailing bytes that should not be encrypted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>aes_error_t </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses SCHM_DEFAULT (PKCS7) as the padding scheme where needed. </dd>
<dd>
While this function can encrypt part or all of the message, it hashes it in its entirely. This is because when sending a packet, only sensitive data need be encrypted but the entire packet should be authenticated. </dd>
<dd>
To encrypt the entire message, pass 0 for <b>encryption_offset</b> and <b>len</b> for <b>encryption_len</b>. </dd>
<dd>
<b>plaintext</b> and <b>ciphertext</b> are aliasable as long as <b>plaintext</b> &gt;= <b>ciphertext</b>. </dd></dl>

</div>
</div>
<a id="a7609df266293fd2fcc98279be119b8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7609df266293fd2fcc98279be119b8e3">&#9670;&nbsp;</a></span>hashlib_AESAuthDecrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashlib_8h.html#aeb2e64abcc4317e3143fb820f21c3bfd">aes_error_t</a> hashlib_AESAuthDecrypt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ciphermode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>decryption_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>decryption_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Authenticated AES Decryption. </p>
<p>Performs an authenticated decryption of the given message. Supports partial decryption via the <b>decryption_offset</b> and <b>decryption_len</b> parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>Pointer to the data to decrypt and authenticate. </td></tr>
    <tr><td class="paramname">len</td><td>The size of the plaintext to decrypt and authenticate. </td></tr>
    <tr><td class="paramname">plaintext</td><td>The buffer to write the authenticated decryption to. Must be at least <b>len-32</b> bytes large. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
    <tr><td class="paramname">iv</td><td>Pointer to an initialization vector (a nonce of length equal to the block size). </td></tr>
    <tr><td class="paramname">ciphermode</td><td>The cipher mode to use. Can be either <em>AES_MODE_CBC</em> or <em>AES_MODE_CTR</em>. </td></tr>
    <tr><td class="paramname">decryption_offset</td><td>The offset from the start of the plaintext to begin decryption. This is useful if you have control bytes or metadata that should not be decrypted. </td></tr>
    <tr><td class="paramname">decryption_len</td><td>The size of the data to be decrypted. This is useful if you have trailing bytes that should not be decrypted. </td></tr>
    <tr><td class="paramname">return</td><td>aes_error_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses SCHM_DEFAULT (PKCS7) as the padding scheme where needed. </dd>
<dd>
This function authenticates the message first by hashing from offset <b>zero</b> to <b>len-32</b> of the ciphertext and comparing that hash to the last 32 bytes of the ciphertext. It assumes those 32 bytes are a hash appended by the remote host. If the hashes do not match, AES_INVALID_CIPHERTEXT is returned and the message is not decrypted. </dd>
<dd>
To decrypt the entire message, pass 0 for <b>decryption_offset</b> and <b>len-32</b> for <b>decryption_len</b>. </dd>
<dd>
<b>plaintext</b> and <b>ciphertext</b> are aliasable as long as <b>plaintext</b> &gt;= <b>ciphertext</b>. </dd></dl>

</div>
</div>
<a id="a5fb66f3d3437a9f5a16e9191a4d46d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb66f3d3437a9f5a16e9191a4d46d74">&#9670;&nbsp;</a></span>hashlib_RSAEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294">rsa_error_t</a> hashlib_RSAEncrypt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>msglen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pubkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSA Encryption. </p>
<p>Performs an in-place RSA encryption of a message over a public modulus <b>pubkey</b> and a public exponent, 65537 OAEP encoding of the input message is performed automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Pointer to a message to encrypt using RSA. </td></tr>
    <tr><td class="paramname">msglen</td><td>The length of the message <b>msg</b>. </td></tr>
    <tr><td class="paramname">ciphertext</td><td>Pointer a buffer to write the ciphertext to. </td></tr>
    <tr><td class="paramname">pubkey</td><td>Pointer to a public key to use for encryption. </td></tr>
    <tr><td class="paramname">keylen</td><td>The length of the public key (modulus) to encrypt with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <b>ciphertext</b> and <b>keylen</b> must be equal. </dd>
<dd>
The <b>msg</b> will be encoded using OAEP before encryption. </dd>
<dd>
msg and pubkey are both treated as byte arrays. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>rsa_error_t </dd></dl>

</div>
</div>
<a id="ada9751a5d91dc4cfcdb90de0518a79f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9751a5d91dc4cfcdb90de0518a79f6">&#9670;&nbsp;</a></span>hashlib_SSLVerifySignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_SSLVerifySignature </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ca_pubkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>certlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sig_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSL Certificate Signature Verification. </p>
<p>Verifies the signature of a given SSL certificate using SSLSIG_RSA_SHA256</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ca_pubkey</td><td>Pointer to buffer containing the public key of the certificate's certifying authority. </td></tr>
    <tr><td class="paramname">keysize</td><td>Length of the public key at <b>ca_pubkey</b>. </td></tr>
    <tr><td class="paramname">cert</td><td>Pointer to buffer containing the certificate to verify. </td></tr>
    <tr><td class="paramname">certlen</td><td>The size of the certificate at <b>cert</b>. </td></tr>
    <tr><td class="paramname">sig_alg</td><td>The algorithm to use for SSL verification (presently only RSA with SHA-256 supported). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the SSL certificate signature is valid. False is invalid or user error. </dd></dl>

</div>
</div>
<a id="afef56629c9316e022d77dfc4623cffeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef56629c9316e022d77dfc4623cffeb">&#9670;&nbsp;</a></span>hashlib_DigestToHexStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_DigestToHexStr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hexstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a digest to a valid hex string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digest</td><td>Pointer to a buffer or digest to convert. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes at <b>digest</b> to convert. </td></tr>
    <tr><td class="paramname">hexstr</td><td>A buffer to write the output hex string to. Must be at least 2 * len + 1 bytes large. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24bf91aef912b8346523f37e16d22377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bf91aef912b8346523f37e16d22377">&#9670;&nbsp;</a></span>hashlib_EraseContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashlib_EraseContext </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Secure erase context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Pointer to any context or buffer you want to erase. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes at <b>ctx</b> to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is advised to call this on every cryptographic context and encryption buffer used. </dd></dl>

</div>
</div>
<a id="afa2188204b9ee6024de788c221a33863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2188204b9ee6024de788c221a33863">&#9670;&nbsp;</a></span>hashlib_CompareDigest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_CompareDigest </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>digest1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>digest2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Secure buffer comparison. </p>
<p>Evaluates the equality of two buffers using a method that offers resistance to timing attacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digest1</td><td>The first buffer to compare. </td></tr>
    <tr><td class="paramname">digest2</td><td>The second buffer to compare. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the buffers were equal. False if not equal. </dd></dl>

</div>
</div>
<a id="aceec2ce59159467d7f78142834360d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceec2ce59159467d7f78142834360d63">&#9670;&nbsp;</a></span>hashlib_ReverseEndianness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_ReverseEndianness </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the endianness of a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Pointer to buffer containing data to reverse. </td></tr>
    <tr><td class="paramname">out</td><td>Pointer to buffer to write the reversed data. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>in</b> and <b>out</b> are not aliasable. </dd></dl>

</div>
</div>
<a id="ab5b8f870cb2e787f0cce92f24c61f070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b8f870cb2e787f0cce92f24c61f070">&#9670;&nbsp;</a></span>hashlib_AESEncryptBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_AESEncryptBlock </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>block_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AES Single-Block Encryption (ECB mode) </p>
<p><a class="anchor" id="autotoc_md0"></a> </p><h5>HELPER FUNCTIONS</h5>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_in</td><td>Pointer to block of data to encrypt. </td></tr>
    <tr><td class="paramname">block_out</td><td>Pointer to buffer to write encrypted block. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>block_in</b> and <b>block_out</b> are aliasable. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>ECB-mode ciphers are insecure (see many-time pad vulnerability). Unless you know what you are doing, use <a class="el" href="hashlib_8h.html#a1206cd9923279d06108d363a9881f79b" title="General-Purpose AES Encryption.">hashlib_AESEncrypt()</a> instead. </dd>
<dd>
The ECB mode single-block encryptors lack the buffer leak protections that <a class="el" href="hashlib_8h.html#a1206cd9923279d06108d363a9881f79b" title="General-Purpose AES Encryption.">hashlib_AESEncrypt()</a> has. If you are writing your own cipher mode, you will need to implement that yourself. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if encryption succeeded. False if failed. </dd></dl>

</div>
</div>
<a id="a12af5da58cdba7080c6101d1fc0542b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12af5da58cdba7080c6101d1fc0542b2">&#9670;&nbsp;</a></span>hashlib_AESDecryptBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_AESDecryptBlock </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>block_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="hashlib_8h.html#aa188bc2768a3b7aa6ad73cb2c77819e0">aes_ctx</a> *&#160;</td>
          <td class="paramname"><em>ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AES Single-Block Decryption (ECB Mode) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_in</td><td>Pointer to block of data to decrypt. </td></tr>
    <tr><td class="paramname">block_out</td><td>Pointer to buffer to write decrypted block. </td></tr>
    <tr><td class="paramname">ks</td><td>Pointer to an AES key schedule context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>block_in</b> and <b>block_out</b> are aliasable. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>ECB-mode ciphers are insecure (see many-time pad vulnerability). Unless you know what you are doing, use <a class="el" href="hashlib_8h.html#a9213710a9ffc0358220c8aa11f395bb2" title="General-Purpose AES Decryption.">hashlib_AESDecrypt()</a> instead. </dd>
<dd>
The ECB mode single-block encryptors lack the buffer leak protections that <a class="el" href="hashlib_8h.html#a9213710a9ffc0358220c8aa11f395bb2" title="General-Purpose AES Decryption.">hashlib_AESDecrypt()</a> has. If you are writing your own cipher mode, you will need to implement that yourself. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if encryption succeeded. False if an error occured. </dd></dl>

</div>
</div>
<a id="a266d90502e38e3bf17c2a2fc5be02388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266d90502e38e3bf17c2a2fc5be02388">&#9670;&nbsp;</a></span>hashlib_AESPadMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashlib_AESPadMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>schm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pads a plaintext according to the specified AES padding scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to buffer containing the data to pad. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at <b>plaintext</b> to pad. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer to write padded data. </td></tr>
    <tr><td class="paramname">schm</td><td>The AES padding scheme to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>plaintext</b> and <b>outbuf</b> are aliasable. </dd>
<dd>
<a class="el" href="hashlib_8h.html#a1206cd9923279d06108d363a9881f79b" title="General-Purpose AES Encryption.">hashlib_AESEncrypt()</a> calls this function automatically. There is no need to do so yourself. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The padded length of the message. </dd></dl>

</div>
</div>
<a id="a7c578a28a265740178be49fce6a8d13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c578a28a265740178be49fce6a8d13d">&#9670;&nbsp;</a></span>hashlib_AESStripPadding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashlib_AESStripPadding </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>schm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips the padding from a message according to the specified AES padding scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to buffer containing the data to strip. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at <b>plaintext</b> to strip. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer to write stripped data. </td></tr>
    <tr><td class="paramname">schm</td><td>The AES padding scheme to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>plaintext</b> and <b>outbuf</b> are aliasable. </dd>
<dd>
<a class="el" href="hashlib_8h.html#a9213710a9ffc0358220c8aa11f395bb2" title="General-Purpose AES Decryption.">hashlib_AESDecrypt()</a> calls this function automatically. There is no need to do so yourself. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the message with padding removed. </dd></dl>

</div>
</div>
<a id="a861a2527b90e2b2412ea715c07f7014d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861a2527b90e2b2412ea715c07f7014d">&#9670;&nbsp;</a></span>hashlib_RSAEncodeOAEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashlib_RSAEncodeOAEP </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>modulus_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>auth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSA-OAEP padding scheme. </p>
<p>Applies the RSA-OAEP padding scheme as indicated in PKCS#1 v2.2. This is intended for use prior to RSA encryption. </p><div class="fragment"><div class="line">| &lt;-------------------------------- modulus size ---------------------------------&gt; |</div>
<div class="line">|-- 0x00 --|-- salt --|-- auth hash --|-- 0x00...padding --|-- 0x01 --|-- message --|</div>
<div class="line">           |          |-------------------------------------------------------------|</div>
<div class="line">                |                                  |</div>
<div class="line">                | --------- MGF1-SHA256 --------&gt; XOR</div>
<div class="line">                |                                  |</div>
<div class="line">               XOR &lt;-------- MGF1-SHA256 --------- |</div>
<div class="line">                |                                  |</div>
<div class="line">|-- 0x00 --|-- msalt --|---------- masked message, padding, and auth hash ----------|</div>
<div class="line">|&lt;-------------------------------- modulus size ----------------------------------&gt; |</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to a buffer containing the data to OAEP-encode. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at <b>plaintext</b> to encode. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer large enough to hold the padded data. </td></tr>
    <tr><td class="paramname">modulus_len</td><td>The byte length of the modulus to pad for. </td></tr>
    <tr><td class="paramname">auth</td><td>Pointer to an authentication string (similar to a password) to include in the encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>outbuf</b> must be at least <b>modulus_len</b> bytes large. </dd>
<dd>
<a class="el" href="hashlib_8h.html#a5fb66f3d3437a9f5a16e9191a4d46d74" title="RSA Encryption.">hashlib_RSAEncrypt()</a> calls this function automatically. There is no need to do it yourself. </dd>
<dd>
<b>auth</b> both sender and receiver must know this string. Pass NULL to omit. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The padded length of the plaintext. </dd></dl>

</div>
</div>
<a id="ab5f471e18b48999cdd4aa61e19cfbfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f471e18b48999cdd4aa61e19cfbfa7">&#9670;&nbsp;</a></span>hashlib_RSADecodeOAEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashlib_RSADecodeOAEP </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>auth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSA-OAEP padding scheme, reverse algorithm. </p>
<p>Reverses the RSA-OAEP padding scheme as indicated in PKCS#1 v2.2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to a buffer containing the data to OAEP-decode. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at <b>plaintext</b> to decode. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer large enough to hold the decoded data. </td></tr>
    <tr><td class="paramname">auth</td><td>Pointer to an authentication string (similar to a password) to include in the encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>outbuf</b> must be at least <b>len-34</b> bytes large. </dd>
<dd>
<b>auth</b> Both sender and reciever must know this string if one is provided. Pass NULL to omit. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The decoded length of the plaintext. </dd></dl>

</div>
</div>
<a id="a63abd0c582f39039601eb341d5c9cb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63abd0c582f39039601eb341d5c9cb35">&#9670;&nbsp;</a></span>hashlib_RSAEncodePSS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashlib_RSAEncodePSS </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>modulus_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>salt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSA-PSS padding scheme. </p>
<p>Applies the RSA-PSS padding scheme as indicated in PKCS#1 v1.5. </p><div class="fragment"><div class="line">|- Message -|  ---------------------- SHA-256 ----------------------&gt;|</div>
<div class="line">                                                                     |</div>
<div class="line">|-- 0x00 padding --|-- 0x01 --|-- salt --|  |-- 8 bytes 0x00 --|-- mHash --|-- salt --|</div>
<div class="line">|----------------------------------------|  |-----------------------------------------|</div>
<div class="line">*DB                  |                      *Mprime              |</div>
<div class="line">                     |                                        SHA-256</div>
<div class="line">                    XOR &lt;------------ MGF1-SHA256 -------------- |</div>
<div class="line">                     |                                           |</div>
<div class="line">                     |                           &lt; ------------- |</div>
<div class="line">                     |                           |</div>
<div class="line">|-------------- masked DB --------------|-- Mprime Hash --|-- 0xbc --|</div>
<div class="line">|-------------------------- modulus size ----------------------------|</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext</td><td>Pointer to buffer containing data to encode. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at <b>plaintext</b> to encode. </td></tr>
    <tr><td class="paramname">outbuf</td><td>Pointer to buffer to write encoded plaintext to. </td></tr>
    <tr><td class="paramname">modulus_len</td><td>The length of the modulus to pad for. </td></tr>
    <tr><td class="paramname">salt</td><td>A nonce equal in length to the SHA-256 digest length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>outbuf</b> must be at least <b>modulus_len</b> bytes large. </dd>
<dd>
<b>salt</b> can be NULL to generate a salt automatically. You can also generate it yourself using <a class="el" href="hashlib_8h.html#ab5d6193b9c9dd748e3ae79f241010354" title="Fills a buffer to size with random bytes.">hashlib_RandomBytes()</a> and pass a pointer to that buffer as <b>salt</b>. </dd>
<dd>
If you are trying to validate a signature, use <a class="el" href="hashlib_8h.html#ada9751a5d91dc4cfcdb90de0518a79f6" title="SSL Certificate Signature Verification.">hashlib_SSLVerifySignature()</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the padded length of the plaintext. </dd></dl>

</div>
</div>
<a id="a07f95403c8ef99fd39d5fcec33cb0ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f95403c8ef99fd39d5fcec33cb0ab3">&#9670;&nbsp;</a></span>hashlib_RSAVerifyPSS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashlib_RSAVerifyPSS </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>modulus_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSA-PSS verification. </p>
<p>Reverses the PSS MGF1 masking on <b>expected</b> and retrieves the salt, then attempts to PSS pad the input given the retrieved salt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to buffer containing data to verify PSS padding for. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data at <b>in</b>. </td></tr>
    <tr><td class="paramname">expected</td><td>Pointer to buffer containing expected signature. </td></tr>
    <tr><td class="paramname">modulus_len</td><td>The size of the signature at <b>expected</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if signature match, False if failed to verify. </dd></dl>

</div>
</div>
<a id="a382c457497fc3f8f8dac7f9dfb296a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382c457497fc3f8f8dac7f9dfb296a71">&#9670;&nbsp;</a></span>hashlib_RSAAuthEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashlib_8h.html#a0486449f609d0e485bad091a671d9294">rsa_error_t</a> hashlib_RSAAuthEncrypt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>msglen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pubkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Authenticated RSA Encryption. </p>
<p>Performs an authenticated encryption of the given message. Does not support partial encryption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Pointer to the data to encrypt and authenticate. </td></tr>
    <tr><td class="paramname">msglen</td><td>The size of the message to encrypt. </td></tr>
    <tr><td class="paramname">ct</td><td>The buffer to write the authenticated encryption to. Must be at least <b>keylen+32</b> bytes large. </td></tr>
    <tr><td class="paramname">pubkey</td><td>Pointer to a bytearray containing the RSA public modulus to encrypt with. </td></tr>
    <tr><td class="paramname">keylen</td><td>The length of the RSA public modulus. </td></tr>
    <tr><td class="paramname">return</td><td>rsa_error_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function calls <a class="el" href="hashlib_8h.html#a5fb66f3d3437a9f5a16e9191a4d46d74" title="RSA Encryption.">hashlib_RSAEncrypt()</a>, which applies the OAEP 2.2 encoding scheme to the message and then encrypts the message using the public modulus supplied. It then hashes the resulting encryption and appends that hash to the end of the ciphertext. </dd>
<dd>
<b>msg</b> and <b>ciphertext</b> are NOT aliasable. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
